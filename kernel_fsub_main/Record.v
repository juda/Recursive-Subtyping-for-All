Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Reflexivity.



Lemma subst_tt_wf: forall E1 E2 A B X,
    WF (E1 ++ E2) A  ->
    WF (E1 ++ (X~bind_sub) ++ E2) B ->
    WF (E1 ++ E2) (subst_tt X A B).
Proof with auto.
  
    intros.
    dependent induction H0;simpl in *...
    +
      destruct (X0==X)...
      constructor...
      analyze_binds H0...
    +
      assert (type A).
      get_type...
      apply WF_rec with (L:=L \u {{X}} \u fv_tt A);intros...
      rewrite subst_tt_open_tt_var...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H0...
      add_nil.
      rewrite_alist (empty ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply wf_weakening...
      rewrite subst_tt_open_tt_var...
      rewrite <- subst_tt_open_tt...
      rewrite_alist (([(X0, bind_sub)] ++ E1) ++ E2).
      apply H2...
      rewrite_alist (empty ++ [(X0, bind_sub)] ++ E1 ++ E2).
      apply wf_weakening...
    +
      constructor...
      apply subst_tt_rt_type with (E:=(E1 ++ (X ~ bind_sub) ++ E2))...
      apply wf_weakening...
      eapply subst_tt_collect...
      eauto.
Qed.


  
  
Lemma WF_drop: forall A i E,
   
    WF E A -> WF E (dropLabel i A).
Proof with auto.
  intros.
  induction H;simpl;try solve [inversion H]...
  apply WF_rec with (L:=L \u fv_tt A \u {{i}});intros.
  unfold open_tt.
  rewrite open_tt_drop_var...
  apply H0...
  rewrite subst_tt_intro with (X:=X)...
  apply subst_tt_wf...
  unfold open_tt.
  rewrite open_tt_drop_var...
  apply H0...
  apply wf_weakening...
  unfold open_tt.
  rewrite open_tt_drop_var...
  apply H0...
  apply notin_drop_fv...
  destruct (i0==i)...
  constructor...
  apply rt_type_drop with (E:=E)...
  apply notin_drop_collect...
Qed.  