Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Antisymmetry.


Lemma label_transform3: forall (X X0:atom) T D,
    X \notin fl_tt T \u {{X0}} ->
    type D ->
    open_tt (subst_label X (subst_tt X (typ_label X D) T))
             (typ_label X0 (open_tt (subst_label X (subst_tt X (typ_label X D) T)) X0))
      = subst_label X (subst_tt X (typ_label X D) (open_tt T (typ_label X0 (open_tt T X0)))).
Proof with auto.
  intros.
  rewrite  subst_tt_open_tt ...
  rewrite subst_label_open_tt ...
  f_equal...
  rewrite drop_label_reverse_type...  
  rewrite drop_label_reverse_type...
  solve_notin.
Qed.

Lemma label_transform4 : forall (X X0:atom) T D,
    X \notin fl_tt T \u {{X0}} ->
    type D ->
    (open_tt (subst_label X (subst_tt X (typ_label X D) T)) X0) = (subst_label X (subst_tt X (typ_label X D) (open_tt T X0))).
Proof with auto.
  intros.
  rewrite <- subst_label_open_tt_var...
  f_equal...
  rewrite subst_tt_open_tt_var...
Qed.  


Lemma binds_subst_label_existial : forall E X Y T U,
    binds X (bind_sub U) (map (drop_label Y) (map (subst_tb Y (typ_label Y T)) E)) ->
    exists Q,
      binds X (bind_sub Q) E.
Proof with auto.
  induction E;intros;simpl in *...
  analyze_binds H...
  destruct a.
  analyze_binds H...
  2: {
    destruct IHE with (X:=X) (Y:=Y) (U:=U) (T:=T)...
    exists x...
  }  
  destruct b;simpl in *.
  dependent destruction BindsTacVal.
  exists t...
  inversion BindsTacVal.
Qed.

Lemma WF_narrowing_env_subst_inv: forall E1 E2 (X:atom) Y S,
    WF (map (subst_tb Y S) E1 ++ Y ~ bind_sub typ_top ++ E2) X ->
    WF (E1 ++ Y ~ bind_sub typ_top ++ E2) X.
Proof with auto.
  induction E1;intros...
  simpl in *.
  destruct a.
  dependent destruction H...
  analyze_binds H...
  -
    destruct b.
    apply WF_var with (U:=t)...
    simpl in *.
    inversion BindsTacVal...
  -
    rewrite_env (nil ++ (a~ b) ++ E1 ++ (Y, bind_sub typ_top) :: E2).
    apply WF_weakening...
    apply IHE1  with (S:=S)...
    apply WF_var with (U:=U)...
  -
    apply WF_var with (U:=typ_top)...
  -
    apply WF_var with (U:=U)...
Qed.   

Lemma binds_subst_extensial: forall E S T X0 X U,
    binds X0 (bind_sub U) (map (subst_tb X S) E) ->
    exists A,
      binds X0 (bind_sub A) (map (subst_tb X T) E).
Proof with auto.
  induction E;intros...
  simpl in *.
  analyze_binds H.
  simpl in *.
  destruct a.
  analyze_binds H.
  -
    destruct b;simpl in *; inversion BindsTacVal.
    exists (subst_tt X T t)...
  -
    apply IHE with (T:=T) in BindsTac...
    destruct_hypos.
    exists x...
Qed.

Lemma WF_narrowing_env: forall E1 E E2 A S T X,
    WF (E1 ++ map (subst_tb X S) E ++ E2) A ->
    WF (E1 ++ map (subst_tb X T) E ++ E2) A.
Proof with auto.
  intros.
  dependent induction H;try solve [analyze_binds H;eauto]...
  -
    analyze_binds H; try solve [apply WF_var with (U:=U);auto].
    apply binds_subst_extensial with (T:=T) in BindsTac0.
    destruct_hypos.
    apply WF_var with (U:=x)...
  -
    apply WF_all with (L:=L )...
    apply IHWF with (S0:=S)...
    intros.
    rewrite_env ((X0 ~ bind_sub T1 ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H1 with (S0:=S)...
  -
    apply WF_rec with (L:=L );intros...
    rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H0 with (S0:=S)...
    rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H2 with (S0:=S)...
Qed.

Lemma sub_map_inv_var: forall X Y X0 C E1 E2, 
    X <> Y -> X0 <> Y ->
  sub (map (subst_tb Y C) E1 ++ (Y, bind_sub typ_top) :: E2) X X0 ->
  sub (map (subst_tb Y C) E1 ++ (Y, bind_sub typ_top) :: E2) X0 X ->
  wf_env (E1 ++ (Y, bind_sub typ_top) :: E2) ->
  sub (E1 ++ (Y, bind_sub typ_top) :: E2) X X0.
Proof with auto.
  intros.
  pose proof suba_sub_tvar_chain H1.
  pose proof suba_sub_tvar_chain H2.
  destruct H4 as [W1 ?].
  destruct H5 as [W2 ?].
  pose proof sub_tvar_chain_antisym H4 H5.
  subst.
  apply sa_fvar...
  get_well_form.
  apply WF_narrowing_env_subst_inv in H6...
Qed.


Lemma subst_label_collect3': forall T i X,
    rt_type T -> type T ->
    i `in` collectLabel T ->
    i `in` collectLabel (subst_label X T).
Proof with auto.
  intros.
  induction H0;try solve [inversion H]...
  simpl in *.
  apply union_iff in H1. apply union_iff.
  destruct H1...
Qed.  


Lemma subst_tt_collect2': forall T i X A,
    i `in` collectLabel T ->
    rt_type T ->
    type T ->
    i `in` collectLabel (subst_tt X A T).
Proof with auto.
  intros.
  induction H1;try solve [inversion H0]...
  simpl in *.
  apply union_iff in H. apply union_iff.
  destruct H...
Qed.  


Lemma drop_label_reverse_wf: forall E1 E2 C D A X,
    WF (map (drop_label X) (map (subst_tb X (typ_label X C)) E1) ++
            (X, bind_sub typ_top) :: E2)
       (subst_label X (subst_tt X (typ_label X D) A)) ->
    X \notin fl_tt A -> type D ->
    WF (E1 ++ (X, bind_sub typ_top) :: E2) A.
Proof with auto.
  intros.
  assert (type A) as HA.
  get_type...
  rewrite drop_label_reverse_type in H... 
  apply type_to_rec in HA.
  generalize dependent E1.
  generalize dependent E2.
  generalize dependent C.
  generalize dependent D.
  generalize dependent X.
  induction HA;intros;simpl in *;try solve [dependent destruction H;auto]...
  -
    destruct (X==X0);subst...
    +
      apply WF_var with (U:=typ_top)...
    +
      simpl in H...
      dependent destruction H...
      analyze_binds H...
      apply binds_subst_label_existial in BindsTac.
      destruct_hypos.
      apply WF_var with (U:=x)...
      apply WF_var with (U:=U)...
  -
    dependent destruction H.
    constructor...
    apply IHHA1 with (C:=C) (D:=D)...
    apply IHHA2 with (C:=C) (D:=D)...
  -
    dependent destruction H5.
    apply WF_rec with (L:=L \u L0 \u {{X}});intros...
    +
      rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply H2 with (C:=C) (D:=D)...
      solve_notin.
      rewrite <- subst_tt_open_tt_var...
      rewrite  subst_label_open_tt_var...
      apply H5...
    +
      rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply H0 with (C:=C) (D:=D)...
      solve_notin.
      rewrite <- label_transform3...
      apply H6...
  -
    dependent destruction H3.
    apply WF_all with (L:=L \u L0 \u {{X}});intros...
    +
      apply IHHA with (C:=C) (D:=D)...
    +
      rewrite_env ((X0 ~ bind_sub T1 ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply H0 with (C:=C) (D:=D)...
      solve_notin.
      rewrite <- label_transform4...
      simpl.
      rewrite drop_label_reverse_type...
      assert (T1 = subst_label X (subst_tt X (typ_label X D) T1)).
      rewrite drop_label_reverse_type ...
      rewrite H6.
      apply H4...
  -
    destruct (l==X);subst...
    +
      apply notin_union  in H0.
      destruct_hypos.
      apply test_solve_notin_7 in H0.
      destruct H0.
    +
      dependent destruction H.
      constructor...
      apply IHHA with (C:=C) (D:=D)...
  -
    dependent destruction H2... 
    apply WF_rcd_cons...
    + apply IHHA1 with (D:=D) (C:=C)...
    + apply IHHA2 with (D:=D) (C:=C)...
    + intros Hc.
      apply H3.
      apply subst_label_collect3' with (X:=X)...
      { apply Infrastructure.subst_tt_rt_type... }
      { apply subst_tt_type... apply type4rec_to_type... }
      apply subst_tt_collect2'...
      apply type4rec_to_type...
Qed.

    
Lemma WF_nominal_inversion: forall E1 E2 X A (X0:atom) D C,
    WF (X0 ~ bind_sub typ_top ++
           map (subst_tb X (typ_label X (open_tt C X))) E1 ++ (X, bind_sub typ_top) :: E2)
          (open_tt (subst_tt X (typ_label X (open_tt D X)) A) X0)->
    X \notin {{X0}} \u fl_tt A  ->
    wf_env (X0 ~ bind_sub typ_top ++
           map (subst_tb X (typ_label X (open_tt C X))) E1 ++ (X, bind_sub typ_top) :: E2) ->
    type (open_tt D X) ->
    WF (X0 ~ bind_sub typ_top ++ E1 ++ (X, bind_sub typ_top) :: E2) (open_tt A X0) .
Proof with auto.
  intros.
  rewrite subst_tt_open_tt_var in H...
  rewrite_env ((X0 ~ bind_sub typ_top ++
           map (subst_tb X (typ_label X (open_tt C X))) E1) ++ (X, bind_sub typ_top) :: E2) in H.
  apply WF_drop_label in H...
  simpl in H...
  rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
  apply drop_label_reverse_wf with (C:=open_tt C X) (D:=open_tt D X)...
  solve_notin.
Qed.

Ltac inv_rt :=
  try solve [
    repeat match goal with
    | [ H : rt_type ?T |- _ ] => inversion H;clear H
    end
      ].

Lemma Tlookup_first_element: forall i T1 T2,
    Tlookup i (typ_rcd_cons i T1 T2) = Some T1.
Proof with auto.
  intros.
  simpl.
  destruct (i==i);subst...
  destruct n...
Qed.

Lemma dropLable_notin: forall T2 i E,
    WF E T2 ->
    rt_type T2 ->
    i `notin` collectLabel T2 ->
    dropLabel i T2 = T2.
Proof with eauto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *.
  destruct (i0==i);subst...
  apply notin_union in H1.
  destruct_hypos.
  apply test_solve_notin_7 in H1...
  destruct H1.
  f_equal...
Qed.

Lemma dropLabel_first_element: forall E i T1 T2,
    WF E (typ_rcd_cons i T1 T2) ->
    dropLabel i (typ_rcd_cons i T1 T2) = T2.
Proof with auto.
  intros.
  dependent destruction H...
  simpl...
  destruct (i==i)...
  apply dropLable_notin with (E:=E)...
  destruct n...
Qed.

Lemma dom_add_subset: forall a E T,
    a \notin E \u T ->
    add a E [<=] add a T ->
    E [<=] T.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  intros.
  specialize (H0 a0).
  assert (a0 \in add a E).
  apply AtomSetImpl.add_2...
  apply H0 in H2.
  apply KeySetProperties.FM.add_iff in H2...
  destruct H2...
  subst...
  assert (False).
  apply H...
  destruct H2.
Qed.

Lemma dom_notin_in: forall (X Y:atom) E,
    X \notin E ->
    Y \in E ->
          X <> Y.
Proof with auto.
  intros...
  unfold "\notin" in *...
  intros.
  apply H...
  subst...
Qed.

Lemma union_swap_assoc: forall A B C,
    A \u B \u C [=] B \u A \u C.
Proof with auto.
  intros.
  rewrite <- AtomSetProperties.union_assoc...
  rewrite <- AtomSetProperties.union_assoc...
  assert (union A B [=] union B A).
  apply AtomSetProperties.union_sym...
  rewrite H...
  apply AtomSetProperties.equal_refl...
Qed.


Lemma drop_collect_flip: forall E A i,
    WF E A ->
    rt_type A ->
    i \in collectLabel A ->
    {{i}} \u collectLabel (dropLabel i A) [=] collectLabel A.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  -
    simpl in *.
    apply empty_iff in H1.
    destruct H1.
  -
    simpl in *...
    destruct (i0==i);subst.
    +
      apply KeySetProperties.union_equal_2...
      rewrite <- notin_drop_collect_self...
      apply AtomSetProperties.equal_refl...
    +
      simpl in *.
      rewrite union_swap_assoc...
      apply KeySetProperties.union_equal_2...
      apply IHWF2...
      apply AtomSetImpl.union_1 in H1.
      destruct H1...
      apply AtomSetImpl.singleton_1 in H1...
      destruct n...
Qed.
    
Lemma record_permutation: forall S2 T2 E i j T1 S1,
    equiv E (typ_rcd_cons i T1 T2) (typ_rcd_cons j S1 S2) ->
    j \in collectLabel (typ_rcd_cons i T1 T2) /\
          (exists T0, Tlookup j (typ_rcd_cons i T1 T2) = Some T0 /\ equiv E T0 S1) /\
          equiv E (dropLabel j (typ_rcd_cons i T1 T2)) S2.
Proof with auto.
  unfold equiv.
  intros.
  destruct_hypos.
  dependent destruction H.
  dependent destruction H6.
  destruct (j==i);subst...
  -
    repeat split...
    +
      apply label_belong with (B:=T1)...
      apply Tlookup_first_element...
    +
      exists T1.
      repeat split...
      apply Tlookup_first_element...
      apply H5 with (i0:=i)...
      apply Tlookup_first_element...
      apply Tlookup_first_element...
      apply H12 with (i0:=i)...
      apply Tlookup_first_element...
      apply Tlookup_first_element...
    +
      rewrite dropLabel_first_element with (E:=E)...
      dependent destruction H3.
      dependent destruction H6.
      dependent destruction H3;dependent destruction H6.
      *
        apply Reflexivity...
      *
        simpl in H2...
        simpl in H7.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        apply dom_add_subset in H2...
        rewrite KeySetProperties.add_union_singleton in H2.
        apply union_empty in H2...
        destruct H2.
      *
        simpl in H12...
        simpl in H4.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        apply dom_add_subset in H12...
        rewrite KeySetProperties.add_union_singleton in H12.
        apply union_empty in H12...
        destruct H12.
      *
        constructor...
        --
          simpl in *...
          rewrite <- KeySetProperties.add_union_singleton in H2.
          rewrite <- KeySetProperties.add_union_singleton in H2.
          rewrite <- KeySetProperties.add_union_singleton in H2.
          rewrite <- KeySetProperties.add_union_singleton in H2.
          apply dom_add_subset in H2...
          rewrite <- KeySetProperties.add_union_singleton.
          rewrite <- KeySetProperties.add_union_singleton...
        --
          intros.
          apply H5 with (i2:=i2)...
          ++
            assert (Hq1:=H3).
            assert (Hq2:=H6).
            apply label_belong in Hq1.
            apply label_belong in Hq2.
            apply dom_notin_in with (X:=i) in Hq1...
            apply dom_notin_in with (X:=i) in Hq2...
            simpl...
            destruct (i==i2);subst...
            destruct Hq1...
          ++
            assert (Hq1:=H3).
            assert (Hq2:=H6).
            apply label_belong in Hq1.
            apply label_belong in Hq2.
            apply dom_notin_in with (X:=i) in Hq1...
            apply dom_notin_in with (X:=i) in Hq2...
            simpl...
            destruct (i==i2);subst...
            destruct Hq1...
    +
      rewrite dropLabel_first_element with (E:=E)...
      dependent destruction H3.
      dependent destruction H6.
      dependent destruction H3;dependent destruction H6.
      *
        apply Reflexivity...
      *
        simpl in H2...
        simpl in H7.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        rewrite <- KeySetProperties.add_union_singleton in H2.
        apply dom_add_subset in H2...
        rewrite KeySetProperties.add_union_singleton in H2.
        apply union_empty in H2...
        destruct H2.
      *
        simpl in H12...
        simpl in H4.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        rewrite <- KeySetProperties.add_union_singleton in H12.
        apply dom_add_subset in H12...
        rewrite KeySetProperties.add_union_singleton in H12.
        apply union_empty in H12...
        destruct H12.
      *
        constructor...
        --
          simpl in *...
          rewrite <- KeySetProperties.add_union_singleton in H12.
          rewrite <- KeySetProperties.add_union_singleton in H12.
          rewrite <- KeySetProperties.add_union_singleton in H12.
          rewrite <- KeySetProperties.add_union_singleton in H12.
          apply dom_add_subset in H12...
          rewrite <- KeySetProperties.add_union_singleton.
          rewrite <- KeySetProperties.add_union_singleton...
        --
          intros.
          apply H14 with (i2:=i2)...
          ++
            assert (Hq1:=H3).
            assert (Hq2:=H6).
            apply label_belong in Hq1.
            apply label_belong in Hq2.
            apply dom_notin_in with (X:=i) in Hq1...
            apply dom_notin_in with (X:=i) in Hq2...
            simpl...
            destruct (i==i2);subst...
            destruct Hq1...
          ++
            assert (Hq1:=H3).
            assert (Hq2:=H6).
            apply label_belong in Hq1.
            apply label_belong in Hq2.
            apply dom_notin_in with (X:=i) in Hq1...
            apply dom_notin_in with (X:=i) in Hq2...
            simpl...
            destruct (i==i2);subst...
            destruct Hq1...
  -
    simpl in H2...
    assert (j \in collectLabel T2) as Hj.
    {
      assert (j `in` collectLabel (typ_rcd_cons i T1 T2)) as HH.
      auto.
      simpl in HH.
      apply AtomSetImpl.union_1 in HH...
      destruct HH...
      apply AtomSetImpl.singleton_1 in H13.
      destruct n...
    }    
    repeat split...
    +
      apply lookup_some in Hj...
      destruct Hj.
      exists x...
      repeat split...
      *
        simpl...
        destruct (i==j);subst...
        destruct n...
      *
        apply H5 with (i0:=j)...
        simpl...
        destruct (i==j);subst...
        destruct n...
        simpl...
        destruct (j==j);subst...
        destruct n0...
      *
        apply H12 with (i0:=j)...
        simpl...
        destruct (j==j);subst...
        destruct n0...
        simpl...
        destruct (i==j);subst...
        destruct n...        
    +
      dependent destruction H3.
      dependent destruction H5.
      constructor...
      *
        apply rt_type_drop with (E:=E)...
      *
        simpl in *.
        destruct (i==j);subst...
        destruct n...
        clear H7 H14.
        simpl.
        apply dom_add_subset with (a:=j)...
        solve_notin.
        apply notin_drop_self...
        rewrite  KeySetProperties.add_union_singleton.
        rewrite  KeySetProperties.add_union_singleton...
        rewrite union_swap_assoc...
        rewrite drop_collect_flip with (E:=E)...
      *
        apply WF_drop...
      *
        intros.
        apply H7 with (i0:=i0)...
        --
          apply Tlookup_drop in H15...
        --
          assert (Ht:=H16).
          apply label_belong in Ht.
          apply dom_notin_in with (Y:=i0) in H6...
          simpl...
          destruct (j==i0);subst...
          destruct H6...
    +
      dependent destruction H3.
      dependent destruction H5.
      constructor...
      *
        apply rt_type_drop with (E:=E)...
      *
        simpl in *.
        destruct (i==j);subst...
        destruct n...
        clear H7 H14.
        simpl.
        apply dom_add_subset with (a:=j)...
        solve_notin.
        apply notin_drop_self...
        rewrite  KeySetProperties.add_union_singleton.
        rewrite  KeySetProperties.add_union_singleton...
        rewrite union_swap_assoc...
        rewrite drop_collect_flip with (E:=E)...
      *
        apply WF_drop...
      *
        intros.
        apply H14 with (i0:=i0)...
        --
          assert (Ht:=H15).
          apply label_belong in Ht.
          apply dom_notin_in with (Y:=i0) in H6...
          simpl...
          destruct (j==i0);subst...
          destruct H6...       
        --
          apply Tlookup_drop in H16...
Qed.      


Lemma lookup_some_in_fl_tt : forall i A x E,
    WF E A -> rt_type A ->
    Tlookup i A = Some x->
    fl_tt x [<=] fl_tt A.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  inversion H1;subst...
  rewrite union_swap_assoc...
  apply KeySetProperties.union_subset_1...
  apply IHWF2 in H1...
  rewrite KeySetProperties.union_sym...
  apply union_subset_6...
  rewrite KeySetProperties.union_sym...
  apply union_subset_6...
Qed.

Lemma lookup_some_subst: forall i A T E X B,
    WF E A -> rt_type A ->
    Tlookup i A = Some T->
    Tlookup i (subst_tt X B A) = Some (subst_tt X B T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  inversion H1...
Qed.

Lemma fl_tt_dropLabel : forall E i T,
    WF E T -> rt_type T ->
    fl_tt (dropLabel i T) [<=] fl_tt T.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  apply AtomSetProperties.FM.Subset_refl...
  simpl in *...
  destruct (i0==i);subst...
  -
    apply IHWF2 in H2...
    rewrite KeySetProperties.union_sym...
    apply union_subset_6...
    rewrite KeySetProperties.union_sym...
    apply union_subset_6...
  -
    simpl in *.
    apply union_subset_x...
    apply union_subset_x...
Qed.

Lemma subst_tt_rcd_cons: forall i X B A D,
    typ_rcd_cons i (subst_tt X D A) (subst_tt X D B) = subst_tt X D (typ_rcd_cons i A B).
Proof with auto.
  intros...
Qed.

Lemma subst_tt_collectLabel_in: forall E T X i D,
    WF E T -> rt_type T ->
    i \in  collectLabel T ->
           i `in` collectLabel (subst_tt X D T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  apply AtomSetImpl.union_1 in H1.
  destruct H1...
Qed.

Lemma subst_tt_dropLabel: forall i T X A E,
    WF E T -> rt_type T ->
    subst_tt X A (dropLabel i T) = dropLabel i (subst_tt X A T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  destruct (i0==i);subst...
  simpl...
  f_equal...
Qed.  

Lemma dropLabel_fv_tt : forall E T A i,
    WF E T -> rt_type T ->
    Tlookup i T = Some A ->
    fv_tt T [=] union (fv_tt A) (fv_tt (dropLabel i T)).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  -
    rewrite dropLable_notin with (E:=E)...
    inversion H1;subst...
    apply KeySetProperties.equal_refl...
  -
    simpl...
    apply IHWF2 in H1...
    rewrite H1.
    rewrite union_swap_assoc...
    apply KeySetProperties.equal_refl...
Qed.    
      
Lemma subst_reverse_equiv: forall A,
    type4rec A -> forall B, type4rec B ->
    forall X C D E1 E2 S,
    X \notin fl_tt A \u fl_tt B \u fv_tt S \u fv_tt C \u fv_tt D->
    equiv (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2 ) (subst_tt X (typ_label X (open_tt C X)) A) (subst_tt X (typ_label X (open_tt D X)) B) ->
    equiv (E1 ++ (X, bind_sub typ_top) :: E2) A B ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt C X) ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt D X) ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt S X) ->
    wf_env (E1 ++ (X, bind_sub typ_top) :: E2) ->
    (equiv ((X, bind_sub typ_top) ::E2) (open_tt C X)  (open_tt D X) \/ (X \notin fv_tt A \u fv_tt B )) .
Proof with auto.
  unfold equiv.
  intros A HA;induction HA;
    intros B HB;induction HB;intros;destruct_hypos;simpl in *;try solve [
      inversion H0;inv_rt|
      inversion H1;inv_rt|
      inversion H2;inv_rt|
      inversion H3;inv_rt|
      inversion H4;inv_rt|
      inversion H5;inv_rt|
      inversion H6;inv_rt|
      inversion H7;inv_rt|
      inversion H8;inv_rt|
      inversion H9;inv_rt|
      inversion H10;inv_rt|
      destruct (X==X0);subst;auto;inversion H0;inv_rt]...
  - destruct (X==X1);destruct (X0==X1);subst...
    +
      dependent destruction H0;inv_rt.
      dependent destruction H7;inv_rt.
      left.
      apply wf_env_cons in H5...
      apply sub_strengthening_env in H0...
      apply sub_strengthening_env in H7...
    +
      inversion H0;inv_rt...
    +
      inversion H7;inv_rt...
  -
    dependent destruction H0;inv_rt.
    dependent destruction H7;inv_rt.
    dependent destruction H1;inv_rt.
    dependent destruction H6;inv_rt.
    clear IHHB1 IHHB2.
    destruct IHHA1 with (B:=T0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
    destruct IHHA2 with (B:=T3) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
  -
    clear H4 H6.
    dependent destruction H8;inv_rt.
    dependent destruction H15;inv_rt.
    dependent destruction H12;inv_rt.
    dependent destruction H15;inv_rt.
    pick fresh Y.
    assert (type (open_tt C X)) by (get_type;auto).
    assert (type (open_tt D X)) by (get_type;auto).
    destruct H0 with (X:=Y) (X0:=X) (B:=open_tt T0 (typ_label Y (open_tt T0 Y))) (C:=C) (D:=D) (E1:=Y~bind_sub typ_top ++E1) (E2:=E2) (S:=S)...
    +
      solve_notin.
    +
      split.
      *
        rewrite_env (Y ~ bind_sub typ_top ++
                     map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
      rewrite subst_tt_open_tt_twice...
      rewrite subst_tt_open_tt_twice...
      *
        rewrite_env (Y ~ bind_sub typ_top ++
                     map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
      rewrite subst_tt_open_tt_twice...
      rewrite subst_tt_open_tt_twice...
    +
      split.
      *
        apply H14...
      *
        apply H17...
    +      
      rewrite_env (Y ~ bind_sub typ_top ++ E1 ++ (X, bind_sub typ_top) :: E2)...
    +
      right.
      apply notin_union in H24.
      destruct_hypos.
      apply notin_fv_open_inv in H24.
      apply notin_fv_open_inv in H25...
  -    
    clear H2 IHHB.
    dependent destruction H4;inv_rt.
    dependent destruction H11;inv_rt.
    dependent destruction H5;inv_rt.
    dependent destruction H10;inv_rt.
    destruct IHHA with (B:=T0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:= E2) (S:=S)...
    clear IHHA.
    pick fresh Y.
    destruct H0 with (B:=open_tt T3 Y) (X:=Y) (X0:=X) (C:=C) (D:=D) (E1:=Y ~ bind_sub T1 ++E1) (E2:=E2) (S:=S);clear H0...
    +
      solve_notin.
    +
      split.
      *
        rewrite <- subst_tt_open_tt_var...
        rewrite <- subst_tt_open_tt_var...
        rewrite_env (nil ++ Y ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) T1) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=subst_tt X (typ_label X (open_tt D X)) T0)...
        --
          clear Fr.
          assert (subst_tt X (typ_label X (open_tt D X)) T0 = subst_tt X (typ_label X (open_tt S X)) T0).
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite H0.
          assert (equiv (X ~ bind_sub typ_top ++ E2) (typ_label X (open_tt S X)) (typ_label X (open_tt S X))).
          {
            apply wf_env_cons in H10.
            unfold equiv;split;constructor;
            apply Reflexivity...
          }
          apply equiv_sub_subst...
        --
          apply H2...
        --
          get_type...
        --
          get_type...
      *
        rewrite <- subst_tt_open_tt_var...
        rewrite <- subst_tt_open_tt_var...
        rewrite_env (nil ++ Y ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) T1) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=subst_tt X (typ_label X (open_tt C X)) T1)...
        --
          clear Fr.
          assert (subst_tt X (typ_label X (open_tt C X)) T1 = subst_tt X (typ_label X (open_tt S X)) T1).
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite H0.
          assert (equiv (X ~ bind_sub typ_top ++ E2) (typ_label X (open_tt S X)) (typ_label X (open_tt S X))).
          {
            apply wf_env_cons in H10.
            unfold equiv;split;constructor;
            apply Reflexivity...
          }
          apply equiv_sub_subst_refl...
          get_well_form...
        --
          apply H4...
        --
          get_type...
        --
          get_type...
    +
      split.
      *
        rewrite_env (nil ++ Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=T0)...
        apply H5...
      *
        rewrite_env (Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2).
        apply H6...        
    +
      rewrite_env (Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2)...
      constructor...
      get_well_form...
    +
      right.
      apply notin_union in H12.
      destruct_hypos.
      apply notin_fv_open_inv in H0.
      apply notin_fv_open_inv in H12.
      solve_notin.
  -
    dependent destruction H0;inv_rt...
    dependent destruction H7;inv_rt...
    dependent destruction H1;inv_rt.
    dependent destruction H6;inv_rt.
    clear IHHB.
    destruct IHHA with (B:=A0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
  -
    dependent destruction H2...
    collect_nil H5.
  -
    dependent destruction H7...
    collect_nil H6.
  -
    clear IHHB1 IHHB2.
    assert (equiv (E1 ++ (X, bind_sub typ_top) :: E2) (typ_rcd_cons i0 T0 T3)  (typ_rcd_cons i T1 T2)) as HE.
    { unfold equiv;split... }
    apply record_permutation in HE...
    unfold equiv in *.
    destruct_hypos.
    destruct IHHA1 with (B:=x) (X:=X) (E1:=E1) (E2:=E2) (C:=C) (D:=D) (S:=S)...
    +
      apply type_to_rec.
      get_type...
    +
      solve_notin.
      apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H11...
      simpl in *.
      apply notin_partial with (E2:=union (singleton i0) (union (fl_tt T0) (fl_tt T3)))...
      get_well_form...
    +
      split.
      *
        clear IHHA1 IHHA2 H9.
        dependent destruction H2.
        apply H8 with (i1:=i)...
        --
          simpl...
          destruct (i==i);subst...
          destruct n...
        --
          rewrite subst_tt_rcd_cons...
          apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
      *
        clear IHHA1 IHHA2 H2.
        dependent destruction H9.
        apply H8 with (i1:=i)...
        --
          rewrite subst_tt_rcd_cons...
          apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
        --
          simpl...
          destruct (i==i);subst...
          destruct n...
    +
      destruct IHHA2 with (B:=dropLabel i (typ_rcd_cons i0 T0 T3)) (X:=X) (E1:=E1) (E2:=E2) (C:=C) (D:=D) (S:=S)...
      *
        apply type_to_rec.
        get_type...
      *
        solve_notin.
        destruct (i0==i);subst...
        --
          apply notin_partial with (E2:=fl_tt T3)...
          apply fl_tt_dropLabel with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
          dependent destruction H30...
        --
          simpl.
          solve_notin.
          apply notin_partial with (E2:=fl_tt T3)...
          apply fl_tt_dropLabel with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
          dependent destruction H25...
      *
        clear IHHA1 IHHA2.
        split.
        --
          clear H9.
          dependent destruction H2.
          constructor...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            get_well_form...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            apply rt_type_drop with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            get_well_form...
            apply WF_drop...
            get_well_form...
          ++
            simpl in *...
            destruct (i0==i);subst...
            **
              apply union_subset_x2 in H5...
              apply KeySetFacts.Subset_trans with (s':=collectLabel (subst_tt X (typ_label X (open_tt D X)) T3))...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              simpl...
              apply drop_coolect_less...
              get_well_form.
              dependent destruction H31...
              dependent destruction H7...
            **
              assert ( WF (E1 ++ (X, bind_sub typ_top) :: E2) T3).
              {
                get_well_form.
                dependent destruction H33...
              }              
              simpl in *...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply union_subset_x2 with (a:=i).
              rewrite union_swap_assoc...
              rewrite drop_collect_flip with (E:=E1 ++ (X, bind_sub typ_top) :: E2) ...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collectLabel_in with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              apply  union_iff in H15.
              destruct H15...
              apply F.singleton_iff in H15...
              destruct n...
              solve_notin.
              apply notin_drop_self...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt C X)).
            simpl.
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt D X)).
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            intros.
            assert (Ht:=H23).
            apply label_belong in Ht.
            simpl...
            apply H8 with (i1:=i1)...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in Ht...
              apply dom_notin_in with (X:=i) in Ht...
              simpl...
              destruct (i==i1);subst...
              destruct Ht...
              apply notin_drop_self...
              get_well_form...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H23...
              apply Tlookup_drop in H23...
              get_well_form...
        --
          clear H2.
          dependent destruction H9.
          constructor...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            apply rt_type_drop with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            get_well_form...
            apply WF_drop...
            get_well_form...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            get_well_form...
          ++
            simpl in *...
            destruct (i0==i);subst...
            **
              get_well_form.
              dependent destruction H30.
              dependent destruction H32.
              apply union_subset_x2 in H5...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite dropLable_notin with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
            **
              assert ( WF (E1 ++ (X, bind_sub typ_top) :: E2) T3).
              {
                get_well_form.
                dependent destruction H33...
              }              
              simpl in *...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply union_subset_x2 with (a:=i).
              rewrite union_swap_assoc...
              rewrite drop_collect_flip with (E:=E1 ++ (X, bind_sub typ_top) :: E2) ...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collectLabel_in with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              apply  union_iff in H15.
              destruct H15...
              apply F.singleton_iff in H15...
              destruct n...
              solve_notin.
              get_well_form.
              dependent destruction H32.
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt D X)).
            simpl.
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt C X)).
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            intros.
            assert (Ht:=H22).
            apply label_belong in Ht.
            apply H8 with (i1:=i1)...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H22...
              apply Tlookup_drop in H22...
              get_well_form...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in Ht...
              apply dom_notin_in with (X:=i) in Ht...
              simpl...
              destruct (i==i1);subst...
              destruct Ht...
              apply notin_drop_self...
              get_well_form...
      *
        clear IHHA1 IHHA2.
        right.
        simpl in *.
        destruct (i0==i);subst.
        --
          inversion H11;subst.
          get_well_form.
          dependent destruction H26.
          rewrite dropLable_notin  with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H34...
        --
          simpl in *.
          assert (fv_tt T3 [=] fv_tt x \u fv_tt (dropLabel i T3)).
          {
            rewrite <- dropLabel_fv_tt with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            apply  KeySetProperties.equal_refl...
            get_well_form.
            dependent destruction H26...
          }
          rewrite H18...
Qed.        
