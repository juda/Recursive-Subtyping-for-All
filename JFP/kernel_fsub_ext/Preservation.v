Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export UnfoldingEquiv.


Lemma Compatible_nat_absurd:
  forall (A:typ),
  Compatible typ_nat A -> False.
Proof with auto.
  intros.
  dependent induction H...
Qed.


Lemma Compatible_arr_absurd:
  forall (A1 A2:typ) B,
  Compatible (typ_arrow A1 A2) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_all_absurd:
  forall (A1 A2:typ) B,
  Compatible (typ_all A1 A2) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_all_lb_absurd:
  forall (A1 A2:typ) B,
  Compatible (typ_all_lb A1 A2) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_label_absurd:
  forall (l:atom) A B,
  Compatible (typ_label l A) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_bvar_absurd:
  forall (n:nat) B,
  Compatible (typ_bvar n) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_mu_absurd:
  forall (A:typ) B,
  Compatible (typ_mu A) B -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1;eauto.
Qed.

Lemma Compatible_top_absurd:
  forall B,
  Compatible typ_top B -> False.
Proof with auto.
  intros.
  dependent induction H...
  (* eapply IHCompatible1;eauto. *)
Qed.

Lemma Compatible_l_split: forall A1 A2 B,
  Compatible (typ_and A1 A2) B ->
  Compatible A1 B /\ Compatible A2 B.
Proof with auto.
  intros.
  dependent induction H...
  destruct (IHCompatible1 A1 A2)...
  destruct (IHCompatible2 A1 A2)...
Qed.

Lemma Compatible_r_split: forall A B1 B2,
  Compatible A (typ_and B1 B2) ->
  Compatible A B1 /\ Compatible A B2.
Proof with auto.
  intros.
  dependent induction H...
  destruct (IHCompatible1 B1 B2)...
  destruct (IHCompatible2 B1 B2)...
Qed.


Lemma Compatible_symm: forall A B,
  Compatible A B ->
  Compatible B A.
Proof with auto.
  intros. induction H;try solve [constructor;auto].
Qed.


Lemma Compatible_var_absurd:
  forall (X:atom) (A:typ),
  Compatible X A -> False.
Proof with auto.
  intros.
  dependent induction H...
  eapply IHCompatible1...
Qed.


Lemma Compatible_bot_absurd:
  forall (A:typ),
  Compatible typ_bot A -> False.
Proof with auto.
  intros.
  dependent induction H...
Qed.



Lemma wf_typ_from_binds_typ : forall x U E,
  wf_env E ->
  binds x (bind_typ U) E ->
  WF E U.
Proof with auto.
  induction 1; intros J; analyze_binds J...
  -
    apply IHwf_env in BindsTac...
    add_nil.
    apply WF_weakening...
  -
    apply IHwf_env in BindsTac...
    add_nil.
    apply WF_weakening...
  -
    inversion BindsTacVal;subst.
    add_nil.
    apply WF_weakening...
  -
    apply IHwf_env in BindsTac...
    add_nil.
    apply WF_weakening...
Qed.

Lemma wf_typ_strengthening : forall E F x U T,
 WF (F ++ x ~ bind_typ U ++ E) T ->
 WF (F ++ E) T.
Proof with eauto.
  intros. 
  dependent induction H...
  -
    analyze_binds H...
  -
    analyze_binds H...
  -
    apply WF_all with (L:=L);intros...
    rewrite_env (((X~ bind_sub T1) ++ F) ++ E)...
    apply H1 with (x0:=x) (U0:=U)...
  -
    apply WF_all_lb with (L:=L);intros...
    rewrite_env (((X~ bind_sub_lb T1) ++ F) ++ E)...
    apply H1 with (x0:=x) (U0:=U)...
  -
    apply WF_rec with (L:=L);intros...
    rewrite_alist (([(X, bind_sub typ_top)] ++ F) ++ E).
    apply H0 with (x0:=x) (U0:=U)...
    rewrite_alist (([(X, bind_sub typ_top)] ++ F) ++ E).
    apply H2 with (x0:=x) (U0:=U)...
Qed.

Lemma wf_open_rec: forall A G,
    WF G (typ_mu A) -> WF G (open_tt A (typ_mu A)).
Proof with auto.
  intros.
  dependent destruction H.
  pick fresh X.
  rewrite subst_tt_intro with (X:=X)...
  rewrite_env (map (subst_tb X (typ_mu A)) nil ++ E).
  apply subst_tb_wf with (Q:=bind_sub typ_top)...
  apply H...
  apply WF_rec with (L:=L)...
Qed.

Lemma wf_open_rec2: forall A G T,
    WF G T ->
    WF G (typ_mu A) -> WF G (open_tt A T).
Proof with auto.
  intros.
  dependent destruction H0.
  pick fresh X.
  rewrite subst_tt_intro with (X:=X)...
  rewrite_env (map (subst_tb X T) nil ++ E).
  apply subst_tb_wf with (Q:=bind_sub typ_top)...
  apply H0...
Qed.


Lemma typing_regular : forall E e T,
  typing E e T ->
  wf_env E /\ expr e /\ WF E T.
Proof with auto.
  intros.
  induction H;destruct_hypos...
  -
    repeat split...
    apply wf_typ_from_binds_typ with (x:=x)...
  -
    pick fresh Y.
    assert (wf_env (Y ~ bind_typ V ++ E)).
    specialize_x_and_L Y L...
    destruct_hypos...
    dependent destruction H1...
    repeat split...
    +
      apply expr_abs with (L:=L)...
      apply WF_type with (E:=E) ...
      intros.
      apply H0...
    +
      constructor...
      specialize_x_and_L Y L...
      destruct_hypos.
      add_nil.
      apply wf_typ_strengthening with (x:=Y) (U:=V)...
  -
    dependent destruction H6.
    repeat split...
  -
    pick fresh Y.
    assert (wf_env (Y ~ bind_sub V ++ E)).
    specialize_x_and_L Y L...
    destruct_hypos...
    dependent destruction H1...
    repeat split...
    +
      apply expr_tabs with (L:=L)...
      apply WF_type with (E:=E) ...
      intros.
      apply H0...
    +
      apply WF_all with (L:=L)...
      intros.
      eapply H0...
  -
    pick fresh Y.
    assert (wf_env (Y ~ bind_sub_lb V ++ E)).
    specialize_x_and_L Y L...
    destruct_hypos...
    dependent destruction H1...
    repeat split...
    +
      apply expr_tabs_lb with (L:=L)...
      apply WF_type with (E:=E) ...
      intros.
      apply H0...
    +
      apply WF_all_lb with (L:=L)...
      intros.
      eapply H0...
  -
    dependent destruction H3.
    repeat split...
    constructor...
    get_type...
    pick fresh X.
    rewrite subst_tt_intro with (X:=X)...
    rewrite_env (map (subst_tb X  T) nil ++ E).
    apply subst_tb_wf with (Q:=bind_sub T1)...
    apply H4...
    get_well_form...
  -
    dependent destruction H3.
    repeat split...
    constructor...
    get_type...
    pick fresh X.
    rewrite subst_tt_intro with (X:=X)...
    rewrite_env (map (subst_tb X  T) nil ++ E).
    apply subst_tb_wf with (Q:=bind_sub_lb T1)...
    apply H4...
    get_well_form...
  -
    get_well_form...
    repeat split...
    constructor...
    apply WF_type with (E:=G)...
  -
    repeat split...
    constructor...
    apply WF_type with (E:=G)...
    apply sub_regular in H0. destruct_hypos.
    apply wf_open_rec2...
  -
    get_well_form.
    repeat split...
  -
    repeat split...
    inversion H2...
  -
    repeat split...
    constructor...
    constructor...
  -
    repeat split...
    constructor...
    constructor...
Qed.


Lemma wf_env_strengthening : forall x T E F,
  wf_env (F ++ x ~ bind_typ T ++ E) ->
  wf_env (F ++ E).
Proof with eauto using wf_typ_strengthening.
  induction F; intros Wf_env; inversion Wf_env; subst; simpl_env in *...
Qed.


Lemma typing_weakening: forall E1 E2 E3 e T,
    typing (E1 ++ E3) e T ->
    wf_env (E1 ++ E2 ++ E3) ->
    typing (E1 ++ E2 ++ E3) e T.
Proof with simpl_env; eauto.
  intros.
  generalize dependent E2.
  dependent induction H;intros...
  -
    apply typing_abs with (L:=L \u dom E1 \u dom E2 \u dom E3).
    intros.
    rewrite_alist (([(x, bind_typ V)] ++ E1) ++ E2 ++ E3).
    apply H0...
    rewrite_alist ([(x, bind_typ V)] ++ E1 ++ E2 ++ E3).
    constructor...
    specialize_x_and_L x L.
    apply typing_regular in H.
    destruct_hypos.
    apply WF_weakening...
    dependent destruction H...
  -
    apply typing_tabs with (L:=L \u dom E1 \u dom E2 \u dom E3).
    intros.
    rewrite_env ((X ~ bind_sub V ++ E1) ++ E2 ++ E3).
    apply H0...
    rewrite_env (X ~ bind_sub V ++ E1 ++ E2 ++ E3).
    constructor...
    specialize_x_and_L X L.
    apply typing_regular in H.
    destruct_hypos.
    apply WF_weakening...
    dependent destruction H...
  -
    apply typing_tabs_lb with (L:=L \u dom E1 \u dom E2 \u dom E3).
    intros.
    rewrite_env ((X ~ bind_sub_lb V ++ E1) ++ E2 ++ E3).
    apply H0...
    rewrite_env (X ~ bind_sub_lb V ++ E1 ++ E2 ++ E3).
    constructor...
    specialize_x_and_L X L.
    apply typing_regular in H.
    destruct_hypos.
    apply WF_weakening...
    dependent destruction H...
  -
    apply typing_tapp with (T1:=T1)...
    apply Sub_weakening...
  -
    apply typing_tapp_lb with (T1:=T1)...
    apply Sub_weakening...
  -
    apply typing_fold with (A:=A)...
    apply Sub_weakening...
  -
    apply typing_unfold...
    apply Sub_weakening...
  -
    apply typing_sub with (S:=S).
    apply IHtyping...
    apply Sub_weakening...
Qed.

Lemma Sub_typ_strengthening : forall E F x U A B,
 sub (F ++ x ~ bind_typ U ++ E) A B ->
 sub (F ++ E) A B.
Proof with eauto using wf_env_strengthening, wf_typ_strengthening.
  intros. 
  dependent induction H...
  -
    apply sa_trans_tvar with (U:=U0)...
    analyze_binds H...
  -
    apply sa_trans_tvar_lb with (U:=U0)...
    analyze_binds H...
  -
    apply sa_all with (L:=L);intros...
    rewrite_env (((X~ bind_sub S2) ++ F) ++ E)...
    apply H2 with (x0:=x) (U0:=U)...
  -
    apply sa_all_lb with (L:=L);intros...
    rewrite_env (((X~ bind_sub_lb S2) ++ F) ++ E)...
    apply H2 with (x0:=x) (U0:=U)...
  -
    apply sa_rec with (L:=L \u {});intros...
    rewrite_alist (([(X, bind_sub typ_top)] ++ F) ++ E).
    specialize_x_and_L X L.
    eapply wf_typ_strengthening with (x:=x) (U:=U)...
    rewrite_alist (([(X, bind_sub typ_top)] ++ F) ++ E).
    specialize_x_and_L X L.
    eapply wf_typ_strengthening with (x:=x) (U:=U)...
    rewrite_alist (([(X, bind_sub typ_top)] ++ F) ++ E).
    apply H2 with (x0:=x) (U0:=U)...
Qed.



Lemma label_choose_reserve_e:
  forall (X : atom) (u : exp) [e : exp],
  expr e -> rt_expr e -> collectLabele e [=] collectLabele (subst_ee X u e).
Proof with auto.
  intros.
  induction H;simpl;try reflexivity...
  + inversion H0.
  + rewrite IHexpr2... reflexivity.
Qed.

Lemma subst_ee_rt_expr : forall A B X,
    rt_expr B ->
    rt_expr (subst_ee X A B).
Proof with auto.
  intros; inversion H; simpl; constructor.
Qed.

Lemma typing_through_subst_ee : forall F U E x T e u,
  typing (F ++ x ~ bind_typ U ++ E) e T ->
  typing E u U ->
  typing (F ++ E) (subst_ee x u e) T.
Proof with eauto.
  intros.
  generalize dependent u.
  dependent induction H;intros;simpl in *...
  -
    constructor...
    apply wf_env_strengthening in H...
  -
    destruct (x0==x);subst...
    +
      analyze_binds_uniq H0...
      apply uniq_from_wf_env...
      inversion BindsTacVal; subst.
      rewrite_alist (nil ++ F ++ E).
      apply typing_weakening...
      apply wf_env_strengthening in H...
    +
      analyze_binds H0...
      constructor...
      apply wf_env_strengthening in H...
      constructor...
      apply wf_env_strengthening in H...
  -
    apply typing_abs with (L:=L \u {{x}})...
    intros.
    rewrite subst_ee_open_ee_var...
    rewrite_alist (([(x0, bind_typ V)] ++ F) ++ E).
    apply H0 with (U0:=U)...
    apply typing_regular in H1...
    destruct_hypos...
  -
    apply typing_tabs with (L:=L \u {{x}})...
    intros.
    rewrite subst_ee_open_te_var...
    rewrite_alist (([(X, bind_sub V)] ++ F) ++ E).
    apply H0 with (U0:=U)...
    apply typing_regular in H1...
    destruct_hypos...
  -
    apply typing_tabs_lb with (L:=L \u {{x}})...
    intros.
    rewrite subst_ee_open_te_var...
    rewrite_alist (([(X, bind_sub_lb V)] ++ F) ++ E).
    apply H0 with (U0:=U)...
    apply typing_regular in H1...
    destruct_hypos...
  -
    apply typing_tapp with (T1:=T1)...
    eapply Sub_typ_strengthening with (x:=x) (U:=U)...
  -
    apply typing_tapp_lb with (T1:=T1)...
    eapply Sub_typ_strengthening with (x:=x) (U:=U)...
  -
    apply typing_fold with (A:=A)...
    apply Sub_typ_strengthening in H...
  -
    apply typing_unfold...
    apply Sub_typ_strengthening in H0...
  -
    apply typing_sub with (S:=S)...
    apply Sub_typ_strengthening in H0...
  -
    apply typing_rcd_nil...
    eapply wf_env_strengthening. apply H.
  -
    constructor...
    +
      apply subst_ee_rt_expr...
    +
      rewrite <- label_choose_reserve_e...
      apply typing_regular in H0. destruct_hypos...
      inversion H5...
Qed.
    

Lemma typing_inv_abs : forall E S1 e1 T,
  typing E (exp_abs S1 e1) T ->
  forall U1 U2, sub E T (typ_arrow U1 U2) ->
     sub E U1 S1
  /\ exists S2, exists L, forall x, x `notin` L ->
     typing (x ~ bind_typ S1 ++ E) (open_ee e1 x) S2 /\ sub E S2 U2.
Proof with auto.
  intros E S1 e1 T Typ.
  dependent induction Typ;intros...
  -
    dependent destruction H1.
    +
      split...
      exists T1. exists L...
  -
    assert (sub E S (typ_arrow U1 U2)).
    apply sub_transitivity with (Q:=T)...
    assert (typing E (exp_abs S1 e1) (typ_arrow U1 U2)).
    apply typing_sub with (S:=S)...
    dependent destruction H2...
Qed.


Lemma binds_map_free_in_typ: forall F X  Y U  P,
    In (X, bind_typ U) F ->
    X <> Y ->
    In (X, bind_typ (subst_tt Y P U)) (map (subst_tb Y P) F).
Proof with auto.
  induction F;intros...
  apply in_inv in H.
  destruct H...
  -
    destruct a.
    inversion H;subst.
    simpl...
  -
    simpl...
Qed.


Lemma binds_map_free_typ: forall E1 E2 X Y U S Q,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub Q) :: E2) ->
    binds X (bind_typ U) (E1 ++ (Y, bind_sub Q) :: E2) ->
    binds X (bind_typ (subst_tt Y S U)) (map (subst_tb Y S) E1 ++  E2).
Proof with auto.
  intros.
  analyze_binds H1...
  -
    unfold binds in *.
    apply In_lemmaL.
    apply binds_map_free_in_typ...
  -
    unfold binds in *.
    apply In_lemmaR.
    rewrite <- maps_subst_tb_free with (X:=Y) (U:=S)...
    apply binds_map_free_in_typ...
    apply notin_from_wf_env in H0...
Qed.


Lemma binds_map_free_typ_lb: forall E1 E2 X Y U S Q,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub_lb Q) :: E2) ->
    binds X (bind_typ U) (E1 ++ (Y, bind_sub_lb Q) :: E2) ->
    binds X (bind_typ (subst_tt Y S U)) (map (subst_tb Y S) E1 ++  E2).
Proof with auto.
  intros.
  analyze_binds H1...
  -
    unfold binds in *.
    apply In_lemmaL.
    apply binds_map_free_in_typ...
  -
    unfold binds in *.
    apply In_lemmaR.
    rewrite <- maps_subst_tb_free with (X:=Y) (U:=S)...
    apply binds_map_free_in_typ...
    apply notin_from_wf_env_lb in H0...
Qed.


Lemma subst_te_rt_expr:
  forall A B X,
  rt_expr B -> type A -> expr B -> rt_expr (subst_te X A B).
Proof.
  intros. induction H;simpl...
  + constructor.
  + constructor.
Qed.


Lemma subst_te_collect: forall i X A e,
    i `notin` collectLabele e ->
    rt_expr e ->
    expr e ->
    i `notin` collectLabele (subst_te X A e).
Proof with auto.
  intros.
  induction H1;try solve [inversion H0]...
  simpl in *.
  apply notin_union in H.
  destruct H.
  apply notin_union.
  split...
Qed.

Lemma subst_tt_type : forall Z P T,
  type T ->
  type P ->
  type (subst_tt Z P T).
Proof with auto.
  intros Z P T HT HP.
  induction HT; simpl...
  destruct (X == Z)...
  pick fresh Y.
  apply type_mu with (L:=L \u {{Z}})...
  intros.
  rewrite subst_tt_open_tt_var...
  pick fresh Y.
  apply type_all with (L:=L \u {{Z}})...
  intros.
  rewrite subst_tt_open_tt_var...
  apply type_all_lb with (L:=L \u {{Z}})...
  intros.
  rewrite subst_tt_open_tt_var...
Qed.

Ltac get_expr :=
    repeat match goal with
    | [ H : typing _ _ _ |- _ ] => apply typing_regular in H;destruct_hypos   
           end.


Lemma typing_through_subst_te : forall Q E F Z e T P,
  typing (F ++ Z ~ bind_sub Q ++ E) e T ->
  sub E P Q ->
  typing (map (subst_tb Z P) F ++ E) (subst_te Z P e) (subst_tt Z P T).
Proof with eauto.
  intros.
  generalize dependent P.
  dependent induction H;intros;simpl...
  -
    constructor...
    apply wf_env_subst_tb with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_subst_tb with (Q:=Q)...
    get_well_form...
    apply binds_map_free_typ with (Q:=Q)...
    analyze_binds_uniq  H0...
    apply uniq_from_wf_env...
  -
    apply typing_abs with (L:=L)...
    intros.
    rewrite subst_te_open_ee_var...
    rewrite_env ( map (subst_tb Z P) (x~bind_typ V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    apply typing_tabs with (L:=L \u {{Z}})...
    intros.
    assert (type P). get_type...
    rewrite subst_te_open_te_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env ( map (subst_tb Z P) (X~bind_sub V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    apply typing_tabs_lb with (L:=L \u {{Z}})...
    intros.
    assert (type P). get_type...
    rewrite subst_te_open_te_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env ( map (subst_tb Z P) (X~bind_sub_lb V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    rewrite subst_tt_open_tt...
    apply typing_tapp with (T1:=subst_tt Z P T1)...
    apply sub_through_subst_tt with (Q:=Q)...
    get_type...
  -
    rewrite subst_tt_open_tt...
    apply typing_tapp_lb with (T1:=subst_tt Z P T1)...
    apply sub_through_subst_tt with (Q:=Q)...
    get_type...
  -
    assert (typ_mu (subst_tt Z P A) = subst_tt Z P (typ_mu A)).
    simpl...
    apply typing_fold with (A:=(subst_tt Z P A) )...
    + rewrite H2. apply sub_through_subst_tt with (Q:=Q)...
    + rewrite <- subst_tt_open_tt... get_type...
  -
    rewrite subst_tt_open_tt...
    apply typing_unfold...
    2:{ get_type... }
    assert (typ_mu (subst_tt Z P T) = subst_tt Z P (typ_mu T))...
    rewrite H2.
    apply sub_through_subst_tt with (Q:=Q)...
  -
    apply typing_sub with (S:=subst_tt Z P S)...
    apply sub_through_subst_tt with (Q:=Q)...
  -
    apply typing_rcd_nil.
    apply wf_env_subst_tb with (Q:=Q)...
    get_well_form...
  -
    apply typing_rcd_cons...
    -- apply subst_te_rt_expr... get_type... get_expr... inversion H5...
    -- solve_notin. apply subst_te_collect... get_expr...
        inversion H5...
    -- eapply subst_tt_compatible in H3...
Qed.


Lemma typing_through_subst_te_lb : forall Q E F Z e T P,
  typing (F ++ Z ~ bind_sub_lb Q ++ E) e T ->
  sub E Q P ->
  typing (map (subst_tb Z P) F ++ E) (subst_te Z P e) (subst_tt Z P T).
Proof with eauto.
  intros.
  generalize dependent P.
  dependent induction H;intros;simpl...
  -
    constructor...
    apply wf_env_subst_tb_lb with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_subst_tb_lb with (Q:=Q)...
    get_well_form...
    apply binds_map_free_typ_lb with (Q:=Q)...
    analyze_binds_uniq  H0...
    apply uniq_from_wf_env...
  -
    apply typing_abs with (L:=L)...
    intros.
    rewrite subst_te_open_ee_var...
    rewrite_env ( map (subst_tb Z P) (x~bind_typ V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    apply typing_tabs with (L:=L \u {{Z}})...
    intros.
    assert (type P). get_type...
    rewrite subst_te_open_te_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env ( map (subst_tb Z P) (X~bind_sub V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    apply typing_tabs_lb with (L:=L \u {{Z}})...
    intros.
    assert (type P). get_type...
    rewrite subst_te_open_te_var...
    rewrite subst_tt_open_tt_var...
    rewrite_env ( map (subst_tb Z P) (X~bind_sub_lb V ++ F) ++ E).
    apply H0 with (Q0:=Q)...
  -
    rewrite subst_tt_open_tt...
    apply typing_tapp with (T1:=subst_tt Z P T1)...
    apply sub_through_subst_tt_lb with (Q:=Q)...
    get_type...
  -
    rewrite subst_tt_open_tt...
    apply typing_tapp_lb with (T1:=subst_tt Z P T1)...
    apply sub_through_subst_tt_lb with (Q:=Q)...
    get_type...
  -
    assert (typ_mu (subst_tt Z P A) = subst_tt Z P (typ_mu A)).
    simpl...
    apply typing_fold with (A:=(subst_tt Z P A) )...
    + rewrite H2. apply sub_through_subst_tt_lb with (Q:=Q)...
    + rewrite <- subst_tt_open_tt... get_type...
  -
    rewrite subst_tt_open_tt...
    apply typing_unfold...
    2:{ get_type... }
    assert (typ_mu (subst_tt Z P T) = subst_tt Z P (typ_mu T))...
    rewrite H2.
    apply sub_through_subst_tt_lb with (Q:=Q)...
  -
    apply typing_sub with (S:=subst_tt Z P S)...
    apply sub_through_subst_tt_lb with (Q:=Q)...
  -
    apply typing_rcd_nil.
    apply wf_env_subst_tb_lb with (Q:=Q)...
    get_well_form...
  -
    apply typing_rcd_cons...
    -- apply subst_te_rt_expr... get_type... get_expr... inversion H5...
    -- solve_notin. apply subst_te_collect... get_expr...
        inversion H5...
    -- eapply subst_tt_compatible in H3...
Qed.


Lemma structural_unfolding_lemma_general: forall A B C D,
  sub empty (typ_mu A) (typ_mu B) ->
  sub empty (typ_mu B) (typ_mu C) ->
  sub empty (typ_mu C) (typ_mu D) ->
  sub empty (open_tt A (typ_mu B)) (open_tt D (typ_mu C)).
Proof with auto.
  intros.
  apply sub_transitivity with (Q:=open_tt B (typ_mu B))...
  2:{ apply sub_transitivity with (Q:=open_tt C (typ_mu C))...
      { apply unfolding_lemma... }
        inversion H1;subst.
        assert ( forall X : atom,
          X `notin` L \u (fv_tt C)->
          sub (X ~ bind_sub typ_top ++ empty) (open_tt C X)
            (open_tt D X)
        ).
        { intros. pick_fresh X0. specialize_x_and_L X0 L.
          apply sub_nominal_inversion in H7...
          rewrite_env (empty ++ X ~ bind_sub typ_top ++ empty).
          apply sub_replacing_var with (X:=X0)... }
        pick_fresh X0.
        replace ((open_tt C (typ_mu C))) with
        (subst_tt X0 (typ_mu C) (open_tt C X0)).
        2:{ rewrite subst_tt_open_tt...
            simpl. rewrite eq_dec_refl.
            f_equal...  rewrite <- subst_tt_fresh...
            apply WF_type with (E:=nil).
            get_well_form... }
        replace ((open_tt D (typ_mu C))) with
        (subst_tt X0 (typ_mu C) (open_tt D X0)).
        2:{ rewrite subst_tt_open_tt...
            simpl. rewrite eq_dec_refl.
            f_equal...  rewrite <- subst_tt_fresh... 
            apply WF_type with (E:=nil).
            get_well_form... }
        rewrite_env (map (subst_tb X0 (typ_mu C)) nil ++ empty).
        apply sub_through_subst_tt with (Q:= typ_top)...
        { apply H2... }
        apply sub_regular in H0. destruct_hypos.
        apply sa_top...
  }
  inversion H;subst.
  assert ( forall X : atom,
    X `notin` L \u (fv_tt A)->
    sub (X ~ bind_sub typ_top ++ empty) (open_tt A X)
      (open_tt B X)
  ).
  { intros. pick_fresh X0. specialize_x_and_L X0 L.
    apply sub_nominal_inversion in H7...
    rewrite_env (empty ++ X ~ bind_sub typ_top ++ empty).
    apply sub_replacing_var with (X:=X0)... }
  pick_fresh X0.
  replace ((open_tt A (typ_mu B))) with
  (subst_tt X0 (typ_mu B) (open_tt A X0)).
  2:{ rewrite subst_tt_open_tt...
      simpl. rewrite eq_dec_refl.
      f_equal...  rewrite <- subst_tt_fresh...
      apply WF_type with (E:=nil).
      get_well_form... }
  replace ((open_tt B (typ_mu B))) with
  (subst_tt X0 (typ_mu B) (open_tt B X0)).
  2:{ rewrite subst_tt_open_tt...
      simpl. rewrite eq_dec_refl.
      f_equal...  rewrite <- subst_tt_fresh... 
      apply WF_type with (E:=nil).
      get_well_form... }
  rewrite_env (map (subst_tb X0 (typ_mu B)) nil ++ empty).
  apply sub_through_subst_tt with (Q:= typ_top)...
  { apply H2... }
  apply sub_regular in H0. destruct_hypos.
  apply sa_top...
Qed.

(* 

mu X. A <: B1 & B2 <: C <: mu X. D

mu X. A <: mu X. B1 & mu X. B2 <: mu X. C <: mu X. D

1) mu X. A <: mu X. B1
2) mu X. A <: mu X. B2 
3) mu X. B1 <: mu X. C or  
   mu X. B2  <: mu X. C
4) mu X. C <: mu X. D

A [X -> mu X. B1] <: D [X -> mu X. C] or A [X -> mu X. B2] <: D [X -> mu X. C]

A [X -> mu X. B1 & mu X. B2 ] <: D [X -> mu X. C]

B1 = Top -> X
B2 = Int -> X

A = Top -> X
D = Top -> X

C = Top -> X

1) mu X. Top -> X <: mu X. Top -> X
2) mu X. Top -> X <: mu X. Int -> X
3) mu X. Top -> X <: mu X. Top -> X
   mu X. Int -> X <: mu X. Top -> X (x)
4) mu X. Top -> X <: mu X. Top -> X

A <: B1, A <: B2, B1 <: C 
B2 <: C (x)

A [X -> mu X. B1 & mu X. B2 ] <: D [X -> mu X. C] ?

Top -> X [X -> mu X. Top -> X & mu X. Int -> X]
<: Top -> X [ X -> mu X. Top -> X ]

Top -> mu X. Top -> X & mu X. Int -> X 
<: Top -> mu X. Top -> X  ? (x)



| typing_fold : forall G A T e ,
      sub G (typ_mu A) T ->
      typing G e (open_tt A T)  ->
      typing G (exp_fold T e) T
 | typing_unfold : forall G A T e,
     typing G e A -> sub G A (typ_mu T) ->
     typing G (exp_unfold A e)  (open_tt T A)


Algo rules:
| typing_fold : forall G A S e T,
     typing G e S ->
     sub G S (open_tt A T) ->
     exposure2 G (typ_mu A) T ->
     WF G T -> (* cannot be removed  *)
     typing G (exp_fold T e) T



      v : A [ X -> T]
      mu X. A <: T
      T <: B
      B <: mu X. C
      --------
      v : C [X -> B]

unfold [?] (fold [?] v) ---> v


v : A [X -> T]
mu X. A <: T
-------------------
fold [T] v : T        T <: B
---------------------------
fold [T] v : B               B <: mu X. C
---------------------------------------------
     unfold [B] (fold [?] v) : C [X -> B]

Goal:  A [X -> T] <: C [X -> B]



mu X. A = mu X. Top -> X
T = mu X. Top -> X & mu X. Int -> X
B = mu X. Top -> X
mu X. C = mu X. Top -> X




v : Top -> (mu X. Top -> X & mu X. Int -> X)
mu X. Top -> X <: mu X. Top -> X & mu X. Int -> X
-------------------
fold [T] v : mu X. Top -> X & mu X. Int -> X
mu X. Top -> X & mu X. Int -> X <: mu X. Top -> X (S-And-l)
---------------------------
fold [T] v : mu X. Top -> X           mu X. Top -> X <: mu X. Top -> X
---------------------------------------------
 unfold [B] (fold [?] v) : Top -> (mu X. Top -> X)

preservation requires:
Top -> (mu X. Top -> X & mu X. Int -> X)
<: Top -> (mu X. Top -> X)


*)


Inductive toplike : typ -> Prop :=
| TL_top: toplike typ_top
| TL_and: forall A B, toplike A -> toplike B -> toplike (typ_and A B).

#[export]
Hint Constructors toplike Compatible : core.



(* 
Lemma sub_toplike: forall E A B,
  wf_env E -> WF E A -> toplike B ->
  sub E A B.
Proof with auto.
  intros.
  induction H1...
  - constructor...
    apply toplike_Compatible...
Qed. *)


Lemma sub_mu_inv: forall A B,
  sub empty (typ_mu A) B ->
  (exists B', B = typ_mu B') \/ toplike B.
Proof with auto.
  intros.
  dependent induction H...
  - inversion H.
  - left. exists A2...
  - destruct IHsub1 with (A0:=A)...
    { destruct H2 as [B' ?]. subst.
      exfalso.
      apply Compatible_mu_absurd in H1... }
    destruct IHsub2 with (A0:=A)...
    { destruct H3 as [B' ?]. subst.
      exfalso. apply Compatible_symm in H1.
      apply Compatible_mu_absurd in H1... }
Qed.

Lemma open_tt_toplike: forall D C,
  toplike C ->
  toplike (open_tt C D).
Proof with auto.
  intros. unfold open_tt.
  induction H.
  - constructor.
  - constructor...
Qed.

Lemma toplike_sub_inv: forall C D,
  sub empty C D ->
  toplike C ->
  toplike D.
Proof with auto.
  intros C D Hsub Htl.
  dependent induction Hsub;try solve [inversion Htl]...
  - inversion H.
  - inversion Htl...
  - inversion Htl...
Qed.



Lemma subtyping_inv_mu: forall A B C D,
  WF empty B -> WF empty C ->
  sub empty (typ_mu A) B ->
  sub empty B C ->
  sub empty C (typ_mu D) ->
  sub empty (open_tt A B) (open_tt D C).
Proof with auto.
  intros.
  generalize dependent C.
  generalize dependent D.

  pose proof sub_mu_inv H1.
  destruct H0 as [[B' ?]|].
  - subst. intros.
    pose proof sub_mu_inv H2.
    destruct H4 as [[C' ?]| ?].
    + subst. apply structural_unfolding_lemma_general...
    + (* require C ordinary *)
      pose proof toplike_sub_inv H3 H4. inversion H5.
      (* dependent induction H15;subst.
      * inversion H7;subst.
      * inversion H12; subst.
        apply IHCompatible1...
        eapply sub_transitivity.
        apply H7. constructor... apply Reflexivity...
      * inversion H14; subst.
        apply IHCompatible2...
        eapply sub_transitivity.
        apply H8. apply sa_and_b... apply Reflexivity...
      * inversion H8.
      * inversion H7. *)
  - 
    intros.
    pose proof toplike_sub_inv H3 H0.
    pose proof toplike_sub_inv H4 H5.
    inversion H6.
Qed.


Lemma typing_inv_fold0: forall T v C B',
typing empty (exp_fold T v) B' ->
forall B, sub empty B' B ->
sub empty B (typ_mu C) ->
exists A, sub empty (typ_mu A) B' /\
(typing empty v 
(* (open_tt A B') 
  /\ sub empty (open_tt A B')  *)
  (open_tt C B)).
Proof with auto.
  intros.
  generalize dependent B.
  generalize dependent C.
  dependent induction H;intros...
  -
    clear IHtyping.
    exists A... repeat split...
    assert (sub empty (open_tt A T) (open_tt C B)). { 
      apply sub_regular in H1 as H1'; destruct_hypos...
      apply subtyping_inv_mu... }
    apply typing_sub with (S:= open_tt A T)...
  - 
    destruct IHtyping with (T0:=T) (v0:=v) (B:=B) (C:=C)...
    { apply sub_transitivity with (Q:=T0)... }
    destruct_hypos.
    exists x. split...
    { apply sub_transitivity with (Q:=S)... }
Qed.


Lemma typing_inv_tabs : forall E S1 e1 T,
typing E (exp_tabs S1 e1) T ->
forall U1 U2 S, sub E T (typ_all U1 U2) -> sub E S U1 ->
  typing (E) (open_te e1 S) (open_tt U2 S).
Proof with auto.
  intros E S1 e1 T H.
  dependent induction H.
  - intros.
   dependent destruction H1.
   pick_fresh X.
     (* exists (L \u L0 \u fv_te e1 \u fv_tt U2). intros. *)
    (* specialize (H X). *)
    rewrite_env (map (subst_tb X S) nil ++ E).
    rewrite subst_te_intro with (X:= X)...
    rewrite subst_tt_intro with (X:= X)...
    apply typing_through_subst_te with (Q:=S1)...
    { specialize_x_and_L X L.
      apply typing_sub with (open_tt T1 X)...
      apply sub_narrowing with (Q:= U1)...
      apply H1... }
    { apply sub_transitivity with (Q:= U1)... }
  - intros.
    pose proof sub_transitivity H0 H1.
    specialize (IHtyping _ _ eq_refl _ _ _ H3 H2)...
Qed.


Lemma typing_inv_tabs_lb : forall E S1 e1 T,
typing E (exp_tabs_lb S1 e1) T ->
forall U1 U2 S, sub E T (typ_all_lb U1 U2) -> sub E U1 S ->
  typing (E) (open_te e1 S) (open_tt U2 S).
Proof with auto.
  intros E S1 e1 T H.
  dependent induction H.
  - intros.
   dependent destruction H1.
   pick_fresh X.
     (* exists (L \u L0 \u fv_te e1 \u fv_tt U2). intros. *)
    (* specialize (H X). *)
    rewrite_env (map (subst_tb X S) nil ++ E).
    rewrite subst_te_intro with (X:= X)...
    rewrite subst_tt_intro with (X:= X)...
    apply typing_through_subst_te_lb with (Q:=S1)...
    { specialize_x_and_L X L.
      apply typing_sub with (open_tt T1 X)...
      apply sub_narrowing_lb with (Q:= U1)...
      apply H1... }
    { apply sub_transitivity with (Q:= U1)... }
  - intros.
    pose proof sub_transitivity H0 H1.
    specialize (IHtyping _ _ eq_refl _ _ _ H3 H2)...
Qed.


Lemma Compatible_bot_absurd_through_sub: forall A B,
  sub empty A typ_bot ->
  Compatible A B ->
  False.
Proof with auto.
  intros. dependent induction H...
  + eapply Compatible_bot_absurd. apply H1.
  + apply IHsub... apply Compatible_l_split in H2; destruct_hypos...
  + apply IHsub... apply Compatible_l_split in H2; destruct_hypos...
Qed.


Lemma bot_uninhabited: forall v,
  value v -> 
  ~ typing empty v typ_bot.
Proof with auto.
  intros.
  intros C. dependent induction C;try solve [inversion H0];
    try solve [inversion H;subst;auto]...
  inversion H0;subst...
  - eapply Compatible_bot_absurd_through_sub. apply H2. apply H3.
  - eapply Compatible_bot_absurd_through_sub. apply H2. apply Compatible_symm. apply H3.
Qed.


Lemma typing_tapp_ub_lb_false: forall e T0 T1 T2,
  typing empty (exp_tabs_lb T0 e) (typ_all T1 T2) -> False.
Proof with auto.
  intros.
  dependent induction H...
  dependent induction H0... 
  - apply bot_uninhabited in H...
    constructor... apply typing_regular in H. destruct_hypos...
  - apply IHtyping with (e0:=e) (T1:=T0) (T2:=S1) (T4:=T3)...
  - eapply IHsub...
    + eapply typing_sub. apply H. constructor...
      apply Reflexivity... apply sub_regular in H0; destruct_hypos...
    + intros. subst. eapply Compatible_all_absurd. apply H1.
  - eapply IHsub...
    + eapply typing_sub. apply H. apply sa_and_b...
      apply Reflexivity... apply sub_regular in H0; destruct_hypos...
    + intros. subst. eapply Compatible_all_absurd. apply Compatible_symm. apply H1.
Qed.


Lemma typing_tapp_lb_ub_false: forall e T0 T1 T2,
  typing empty (exp_tabs T0 e) (typ_all_lb T1 T2) -> False.
Proof with auto.
  intros.
  dependent induction H...
  dependent induction H0... 
  - apply bot_uninhabited in H...
    constructor... apply typing_regular in H. destruct_hypos...
  - apply IHtyping with (e0:=e) (T1:=T0) (T2:=S1) (T4:=T3)...
  - eapply IHsub...
    + eapply typing_sub. apply H. constructor...
      apply Reflexivity... apply sub_regular in H0; destruct_hypos...
    + intros. subst. eapply Compatible_all_lb_absurd. apply H1.
  - eapply IHsub...
    + eapply typing_sub. apply H. apply sa_and_b...
      apply Reflexivity... apply sub_regular in H0; destruct_hypos...
    + intros. subst. eapply Compatible_all_lb_absurd. apply Compatible_symm. apply H1.
Qed.


Lemma step_rt_expr: forall e1 e2,
  rt_expr e1 ->
  step e1 e2 ->
  rt_expr e2.
Proof with auto.
  intros. destruct H.
  - dependent destruction H0...
  - dependent destruction H0...
    constructor. constructor.
Qed.

Lemma rt_expr_collectLabele: forall e1 e2,
    step e1 e2 -> rt_expr e1 -> expr e1 ->
    collectLabele e2 [<=] collectLabele e1.
Proof with auto.
  intros.
  induction H;simpl;try reflexivity; try apply AtomSetProperties.subset_empty;
  try solve [match goal with
  | [H : rt_expr _ |- _] => inversion H
  end].
  - inversion H1;subst. rewrite IHstep... reflexivity.
Qed.


Lemma Compatible_single_cannot_sub: forall i T1 T2 Ti,
  Compatible (typ_single i T1) T2 ->
  sub empty T2 (typ_single i Ti) ->
  False.
Proof with auto.
  intros. dependent induction H0...
  - eapply Compatible_bot_absurd. apply Compatible_symm. apply H.
  - inversion H. apply H2...
  - dependent destruction H. apply IHsub with i Ti...
  - dependent destruction H. apply IHsub with i Ti...
Qed.


Lemma proj_prev_subgeneralize: forall e T i Ti vi,
  typing empty e T ->
  sub empty T (typ_single i Ti) ->
  tlookup i e = Some vi ->
  typing empty vi Ti.
Proof with auto.
  intros.
  dependent induction e; try solve [inversion H1].
  simpl in H1. destruct (a==i); subst.
  * inversion H1; subst. clear IHe1 IHe2. dependent induction H.
    -- eapply IHtyping... apply sub_transitivity with T...
    -- dependent destruction H0.
       apply typing_sub with T...
    -- dependent destruction H4...
     --- inversion H5; subst. apply typing_sub with T1...
     --- exfalso. eapply Compatible_single_cannot_sub. apply H6. apply H5.
  * clear IHe1. dependent induction H.
    -- eapply IHtyping...
     --- intros. eapply IHe2... apply H3. apply H4. apply H5.
     --- apply sub_transitivity with T...
    -- simpl in H1. inversion H1.
    -- eapply IHe2...
     --- apply H0.
     --- dependent destruction H4.
      ---- inversion H4; subst. exfalso. apply n. reflexivity.
      ---- apply H4.
     --- auto.
Qed.

Lemma proj_prev: forall e i Ti vi,
  typing empty e (typ_single i Ti) ->
  tlookup i e = Some vi ->
  typing empty vi Ti.
Proof with auto.
  intros.
  apply proj_prev_subgeneralize with (e:=e) (T:=typ_single i Ti) (i:=i)...
  apply sa_single; apply Reflexivity...
  apply typing_regular in H; destruct_hypos. inversion H2...
Qed.

Lemma preservation : forall e e' T,
    typing nil e T ->
    step e e' ->
    typing nil e' T.
Proof with auto.
  intros.
  generalize dependent e'.
  dependent induction H;intros;try solve [dependent destruction H1;auto|inversion H0]...
  -
    dependent destruction H1...
    +
      dependent destruction H.
      *
        pick fresh Y.
        rewrite subst_ee_intro with (x:=Y)...
        rewrite_env (empty ++ empty).
        apply typing_through_subst_ee with (U:=T1)...
        apply H...
      *
        apply typing_inv_abs with (U1:=T1) (U2:=T2) in H...
        destruct_hypos.
        pick fresh Y.
        rewrite subst_ee_intro with (x:=Y)...
        rewrite_env (empty ++ empty).
        apply typing_through_subst_ee with (U:=T)...
        specialize_x_and_L Y x0.
        destruct_hypos.
        apply typing_sub with (S:=x)...
        apply Sub_weakening...
        constructor...
        get_well_form...
        (* apply typing_regular in H4... *)
        destruct_hypos...
        (* dependent destruction H4... *)
        apply typing_sub with (S:=T1)...
    +
      apply typing_app with (T1:=T1)...
    +
      apply typing_app with (T1:=T1)...
  -
    dependent destruction H1...
    +
      apply typing_tapp with (T1:=T1)...
    +
      dependent destruction H...
      *
        pick fresh X.
        rewrite subst_te_intro with (X:=X)...
        rewrite subst_tt_intro with (X:=X)...
        rewrite_alist (map (subst_tb X T) nil ++ empty).
        apply typing_through_subst_te with (Q:=T1)...
        apply H...
      *


      (* 

      
      /\X<:S1. e1 <: T <: ALL U1. U2
      T0 <: U1

      e1 [X |-> T0] : U2 [X |-> T0]
      
      *)
        apply typing_inv_tabs with (U1:=T1) (U2:=T2) (S:=T) in H...
        (* destruct H as [L ?]. pick_fresh X. 
        destruct_hypos.
        pick fresh X.
        rewrite subst_te_intro with (X:=X)...
        rewrite subst_tt_intro with (X:=X)...
        rewrite_alist (map (subst_tb X T) nil ++ empty).
        apply typing_through_subst_te with (Q:=T1)...
        specialize_x_and_L X x0.
        destruct_hypos.
        apply typing_sub with (S:=open_tt x X)... *)
    +
      apply typing_tapp_ub_lb_false in H. destruct H.
  -
    dependent destruction H1...
    +
      apply typing_tapp_lb with (T1:=T1)...
    +
      apply typing_tapp_lb_ub_false in H. destruct H.
    +
      dependent destruction H...
      *
        pick fresh X.
        rewrite subst_te_intro with (X:=X)...
        rewrite subst_tt_intro with (X:=X)...
        rewrite_alist (map (subst_tb X T) nil ++ empty).
        apply typing_through_subst_te_lb with (Q:=T1)...
        apply H...
      *
        apply typing_inv_tabs_lb with (U1:=T1) (U2:=T2) (S:=T) in H...

  -
    dependent destruction H1...
    apply typing_fold with (A:=A)...
  -
    dependent destruction H1...
    (* 2:{ apply IHtyping in H2...
        apply typing_unfold with (A:=A)... } *)
    eapply typing_inv_fold0 with (C:=T) (B:=A) in H...
    destruct_hypos...
    apply Reflexivity... get_well_form...
  -
    apply typing_sub with (S:=S)...

  -
    dependent destruction H0...
    + apply proj_prev with e i...
  -
    dependent destruction H0...
    inversion H1;subst...
  -
    dependent destruction H4... 
    inversion H5;subst...
    apply typing_rcd_cons...
    + apply step_rt_expr with e3... 
    + solve_notin. rewrite rt_expr_collectLabele... get_expr...
      inversion H6...
Qed.