Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Reverse.
            

Lemma choose_flip: forall m A B ,
    choose m A B = choose (flip m) B A .
Proof with auto.
  intros.
  destruct m...
Qed.


Lemma WF_narrowing_env: forall E1 E E2 A S T X,
    WF (E1 ++ map (subst_tb X S) E ++ E2) A ->
    WF (E1 ++ map (subst_tb X T) E ++ E2) A.
Proof with auto.
  intros.
  dependent induction H;try solve [analyze_binds H;eauto]...
  -
    analyze_binds H; try solve [apply WF_var with (U:=U);auto].
    apply binds_subst_extensial with (T:=T) in BindsTac0.
    destruct_hypos.
    apply WF_var with (U:=x)...
  -
    apply WF_all with (L:=L )...
    apply IHWF with (S0:=S)...
    intros.
    rewrite_env ((X0 ~ bind_sub T1 ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H1 with (S0:=S)...
  -
    apply WF_rec with (L:=L );intros...
    rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H0 with (S0:=S)...
    rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ map (subst_tb X T) E ++ E2). 
    eapply H2 with (S0:=S)...
Qed.


Lemma lookup_some_in_fl_tt : forall i A x E,
    WF E A -> rt_type A ->
    Tlookup i A = Some x->
    fl_tt x [<=] fl_tt A.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  inversion H1;subst...
  rewrite union_swap_assoc...
  apply KeySetProperties.union_subset_1...
  apply IHWF2 in H1...
  rewrite KeySetProperties.union_sym...
  apply union_subset_6...
  rewrite KeySetProperties.union_sym...
  apply union_subset_6...
Qed.

Lemma lookup_some_subst: forall i A T E X B,
    WF E A -> rt_type A ->
    Tlookup i A = Some T->
    Tlookup i (subst_tt X B A) = Some (subst_tt X B T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  inversion H1...
Qed.

Lemma fl_tt_dropLabel : forall E i T,
    WF E T -> rt_type T ->
    fl_tt (dropLabel i T) [<=] fl_tt T.
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  apply AtomSetProperties.FM.Subset_refl...
  simpl in *...
  destruct (i0==i);subst...
  -
    apply IHWF2 in H2...
    rewrite KeySetProperties.union_sym...
    apply union_subset_6...
    rewrite KeySetProperties.union_sym...
    apply union_subset_6...
  -
    simpl in *.
    apply union_subset_x...
    apply union_subset_x...
Qed.

Lemma subst_tt_rcd_cons: forall i X B A D,
    typ_rcd_cons i (subst_tt X D A) (subst_tt X D B) = subst_tt X D (typ_rcd_cons i A B).
Proof with auto.
  intros...
Qed.

Lemma subst_tt_collectLabel_in: forall E T X i D,
    WF E T -> rt_type T ->
    i \in  collectLabel T ->
           i `in` collectLabel (subst_tt X D T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  apply AtomSetImpl.union_1 in H1.
  destruct H1...
Qed.

Lemma subst_tt_dropLabel: forall i T X A E,
    WF E T -> rt_type T ->
    subst_tt X A (dropLabel i T) = dropLabel i (subst_tt X A T).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  destruct (i0==i);subst...
  simpl...
  f_equal...
Qed.  

Lemma dropLabel_fv_tt : forall E T A i,
    WF E T -> rt_type T ->
    Tlookup i T = Some A ->
    fv_tt T [=] union (fv_tt A) (fv_tt (dropLabel i T)).
Proof with auto.
  intros.
  induction H;try solve [inversion H0]...
  simpl in *...
  inversion H1...
  simpl in *.
  destruct (i0==i);subst...
  -
    rewrite dropLable_notin with (E:=E)...
    inversion H1;subst...
    apply KeySetProperties.equal_refl...
  -
    simpl...
    apply IHWF2 in H1...
    rewrite H1.
    rewrite union_swap_assoc...
    apply KeySetProperties.equal_refl...
Qed.    
      
Lemma subst_reverse_equiv: forall A,
    type4rec A -> forall B, type4rec B ->
    forall X C D E1 E2 S,
    X \notin fl_tt A \u fl_tt B \u fv_tt S \u fv_tt C \u fv_tt D->
    equiv (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2 ) (subst_tt X (typ_label X (open_tt C X)) A) (subst_tt X (typ_label X (open_tt D X)) B) ->
    equiv (E1 ++ (X, bind_sub typ_top) :: E2) A B ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt C X) ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt D X) ->
    WF ((X, bind_sub typ_top) :: E2) (open_tt S X) ->
    wf_env (E1 ++ (X, bind_sub typ_top) :: E2) ->
    (equiv ((X, bind_sub typ_top) ::E2) (open_tt C X)  (open_tt D X) \/ (X \notin fv_tt A \u fv_tt B )) .
Proof with auto.
  unfold equiv.
  intros A HA;induction HA;
    intros B HB;induction HB;intros;destruct_hypos;simpl in *;try solve [
      inversion H0;inv_rt|
      inversion H1;inv_rt|
      inversion H2;inv_rt|
      inversion H3;inv_rt|
      inversion H4;inv_rt|
      inversion H5;inv_rt|
      inversion H6;inv_rt|
      inversion H7;inv_rt|
      inversion H8;inv_rt|
      inversion H9;inv_rt|
      inversion H10;inv_rt|
      destruct (X==X0);subst;auto;inversion H0;inv_rt]...
  - destruct (X==X1);destruct (X0==X1);subst...
    +
      dependent destruction H0;inv_rt.
      dependent destruction H7;inv_rt.
      left.
      apply wf_env_cons in H5...
      apply sub_strengthening_env in H0...
      apply sub_strengthening_env in H7...
    +
      inversion H0;inv_rt...
    +
      inversion H7;inv_rt...
  -
    dependent destruction H0;inv_rt.
    dependent destruction H7;inv_rt.
    dependent destruction H1;inv_rt.
    dependent destruction H6;inv_rt.
    clear IHHB1 IHHB2.
    destruct IHHA1 with (B:=T0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
    destruct IHHA2 with (B:=T3) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
  -
    clear H4 H6.
    dependent destruction H8;inv_rt.
    dependent destruction H15;inv_rt.
    dependent destruction H12;inv_rt.
    dependent destruction H15;inv_rt.
    pick fresh Y.
    assert (type (open_tt C X)) by (get_type;auto).
    assert (type (open_tt D X)) by (get_type;auto).
    destruct H0 with (X:=Y) (X0:=X) (B:=open_tt T0 (typ_label Y (open_tt T0 Y))) (C:=C) (D:=D) (E1:=Y~bind_sub typ_top ++E1) (E2:=E2) (S:=S)...
    +
      solve_notin.
    +
      split.
      *
        rewrite_env (Y ~ bind_sub typ_top ++
                     map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
      rewrite subst_tt_open_tt_twice...
      rewrite subst_tt_open_tt_twice...
      *
        rewrite_env (Y ~ bind_sub typ_top ++
                     map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
      rewrite subst_tt_open_tt_twice...
      rewrite subst_tt_open_tt_twice...
    +
      split.
      *
        apply H14...
      *
        apply H17...
    + 
      rewrite_env (Y ~ bind_sub typ_top ++ E1 ++ (X, bind_sub typ_top) :: E2)...
    +
      right.
      apply notin_union in H24.
      destruct_hypos.
      apply notin_fv_open_inv in H24.
      apply notin_fv_open_inv in H25...
  -
    clear H2 IHHB.
    dependent destruction H4;inv_rt.
    dependent destruction H11;inv_rt.
    dependent destruction H5;inv_rt.
    dependent destruction H10;inv_rt.
    destruct IHHA with (B:=T0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:= E2) (S:=S)...
    clear IHHA.
    pick fresh Y.
    destruct H0 with (B:=open_tt T3 Y) (X:=Y) (X0:=X) (C:=C) (D:=D) (E1:=Y ~ bind_sub T1 ++E1) (E2:=E2) (S:=S);clear H0...
    +
      solve_notin.
    +
      split.
      *
        rewrite <- subst_tt_open_tt_var...
        rewrite <- subst_tt_open_tt_var...
        rewrite_env (nil ++ Y ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) T1) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=subst_tt X (typ_label X (open_tt D X)) T0)...
        --
          clear Fr.
          assert (subst_tt X (typ_label X (open_tt D X)) T0 = subst_tt X (typ_label X (open_tt S X)) T0).
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite H0.
          assert (equiv (X ~ bind_sub typ_top ++ E2) (typ_label X (open_tt S X)) (typ_label X (open_tt S X))).
          {
            apply wf_env_cons in H10.
            unfold equiv;split;constructor;
            apply Reflexivity...
          }
          apply equiv_sub_subst...
        --
          apply H2...
        --
          get_type...
        --
          get_type...
      *
        rewrite <- subst_tt_open_tt_var...
        rewrite <- subst_tt_open_tt_var...
        rewrite_env (nil ++ Y ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) T1) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=subst_tt X (typ_label X (open_tt C X)) T1)...
        --
          clear Fr.
          assert (subst_tt X (typ_label X (open_tt C X)) T1 = subst_tt X (typ_label X (open_tt S X)) T1).
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite H0.
          assert (equiv (X ~ bind_sub typ_top ++ E2) (typ_label X (open_tt S X)) (typ_label X (open_tt S X))).
          {
            apply wf_env_cons in H10.
            unfold equiv;split;constructor;
            apply Reflexivity...
          }
          apply equiv_sub_subst_refl...
          get_well_form...
        --
          apply H4...
        --
          get_type...
        --
          get_type...
    +
      split.
      *
        rewrite_env (nil ++ Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2).
        apply sub_narrowing with (Q:=T0)...
        apply H5...
      *
        rewrite_env (Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2).
        apply H6...        
    +
      rewrite_env (Y ~ bind_sub T1 ++ E1 ++ (X, bind_sub typ_top) :: E2)...
      constructor...
      get_well_form...
    +
      right.
      apply notin_union in H12.
      destruct_hypos.
      apply notin_fv_open_inv in H0.
      apply notin_fv_open_inv in H12.
      solve_notin.
  -
    dependent destruction H0;inv_rt...
    dependent destruction H7;inv_rt...
    dependent destruction H1;inv_rt.
    dependent destruction H6;inv_rt.
    clear IHHB.
    destruct IHHA with (B:=A0) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S)...
  -
    dependent destruction H2...
    collect_nil H5.
  -
    dependent destruction H7...
    collect_nil H6.
  -
    clear IHHB1 IHHB2.
    assert (equiv (E1 ++ (X, bind_sub typ_top) :: E2) (typ_rcd_cons i0 T0 T3)  (typ_rcd_cons i T1 T2)) as HE.
    { unfold equiv;split... }
    apply record_permutation in HE...
    unfold equiv in *.
    destruct_hypos.
    destruct IHHA1 with (B:=x) (X:=X) (E1:=E1) (E2:=E2) (C:=C) (D:=D) (S:=S)...
    +
      apply type_to_rec.
      get_type...
    +
      solve_notin.
      apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H11...
      simpl in *.
      apply notin_partial with (E2:=union (singleton i0) (union (fl_tt T0) (fl_tt T3)))...
      get_well_form...
    +
      split.
      *
        clear IHHA1 IHHA2 H9.
        dependent destruction H2.
        apply H8 with (i1:=i)...
        --
          simpl...
          destruct (i==i);subst...
          destruct n...
        --
          rewrite subst_tt_rcd_cons...
          apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
      *
        clear IHHA1 IHHA2 H2.
        dependent destruction H9.
        apply H8 with (i1:=i)...
        --
          rewrite subst_tt_rcd_cons...
          apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
        --
          simpl...
          destruct (i==i);subst...
          destruct n...
    +
      destruct IHHA2 with (B:=dropLabel i (typ_rcd_cons i0 T0 T3)) (X:=X) (E1:=E1) (E2:=E2) (C:=C) (D:=D) (S:=S)...
      *
        apply type_to_rec.
        get_type...
      *
        solve_notin.
        destruct (i0==i);subst...
        --
          apply notin_partial with (E2:=fl_tt T3)...
          apply fl_tt_dropLabel with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
          dependent destruction H30...
        --
          simpl.
          solve_notin.
          apply notin_partial with (E2:=fl_tt T3)...
          apply fl_tt_dropLabel with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))...
          get_well_form...
          dependent destruction H25...
      *
        clear IHHA1 IHHA2.
        split.
        --
          clear H9.
          dependent destruction H2.
          constructor...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            get_well_form...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            apply rt_type_drop with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            get_well_form...
            apply WF_drop...
            get_well_form...
          ++
            simpl in *...
            destruct (i0==i);subst...
            **
              apply union_subset_x2 in H5...
              apply KeySetFacts.Subset_trans with (s':=collectLabel (subst_tt X (typ_label X (open_tt D X)) T3))...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              simpl...
              apply drop_coolect_less...
              get_well_form.
              dependent destruction H31...
              dependent destruction H7...
            **
              assert ( WF (E1 ++ (X, bind_sub typ_top) :: E2) T3).
              {
                get_well_form.
                dependent destruction H33...
              }              
              simpl in *...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply union_subset_x2 with (a:=i).
              rewrite union_swap_assoc...
              rewrite drop_collect_flip with (E:=E1 ++ (X, bind_sub typ_top) :: E2) ...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collectLabel_in with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              apply  union_iff in H15.
              destruct H15...
              apply F.singleton_iff in H15...
              destruct n...
              solve_notin.
              apply notin_drop_self...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt C X)).
            simpl.
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt D X)).
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            intros.
            assert (Ht:=H23).
            apply label_belong in Ht.
            simpl...
            apply H8 with (i1:=i1)...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in Ht...
              apply dom_notin_in with (X:=i) in Ht...
              simpl...
              destruct (i==i1);subst...
              destruct Ht...
              apply notin_drop_self...
              get_well_form...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H23...
              apply Tlookup_drop in H23...
              get_well_form...
        --
          clear H2.
          dependent destruction H9.
          constructor...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            apply rt_type_drop with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            get_well_form...
            apply WF_drop...
            get_well_form...
          ++
            apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_weakening...
            get_well_form...
          ++
            simpl in *...
            destruct (i0==i);subst...
            **
              get_well_form.
              dependent destruction H30.
              dependent destruction H32.
              apply union_subset_x2 in H5...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite dropLable_notin with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
            **
              assert ( WF (E1 ++ (X, bind_sub typ_top) :: E2) T3).
              {
                get_well_form.
                dependent destruction H33...
              }              
              simpl in *...
              rewrite subst_tt_dropLabel with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
              apply union_subset_x2 with (a:=i).
              rewrite union_swap_assoc...
              rewrite drop_collect_flip with (E:=E1 ++ (X, bind_sub typ_top) :: E2) ...
              apply subst_tt_wf...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_rt_type with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              rewrite_env (nil ++ E1 ++ (X, bind_sub typ_top) :: E2).
              apply WF_weakening...
              apply subst_tt_collectLabel_in with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
              apply  union_iff in H15.
              destruct H15...
              apply F.singleton_iff in H15...
              destruct n...
              solve_notin.
              get_well_form.
              dependent destruction H32.
              apply subst_tt_collect with (E:= E1 ++ (X, bind_sub typ_top) :: E2)...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt D X)).
            simpl.
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            rewrite_env (nil ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
            apply WF_narrowing_env with (S:=typ_label X (open_tt C X)).
            apply subst_tb_wf2 with (Q:=bind_sub typ_top)...
            get_well_form...
          ++
            intros.
            assert (Ht:=H22).
            apply label_belong in Ht.
            apply H8 with (i1:=i1)...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H22...
              apply Tlookup_drop in H22...
              get_well_form...
            **
              rewrite subst_tt_dropLabel with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in Ht...
              apply dom_notin_in with (X:=i) in Ht...
              simpl...
              destruct (i==i1);subst...
              destruct Ht...
              apply notin_drop_self...
              get_well_form...
      *
        clear IHHA1 IHHA2.
        right.
        simpl in *.
        destruct (i0==i);subst.
        --
          inversion H11;subst.
          get_well_form.
          dependent destruction H26.
          rewrite dropLable_notin  with (E:=E1 ++ (X, bind_sub typ_top) :: E2) in H34...
        --
          simpl in *.
          assert (fv_tt T3 [=] fv_tt x \u fv_tt (dropLabel i T3)).
          {
            rewrite <- dropLabel_fv_tt with (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            apply  KeySetProperties.equal_refl...
            get_well_form.
            dependent destruction H26...
          }
          rewrite H18...
Qed.


Lemma subst_tt_wf_env_label_rec: forall E1 X E2 U,
    wf_env (map (subst_tb X (typ_label X (open_tt U X))) E1 ++ (X, bind_sub typ_top) :: E2) ->
    X \notin fv_tt U \u fl_env E1 ->
    WF E2 (typ_mu U) ->
    wf_env (map (subst_tb X (typ_mu U)) E1 ++ E2).
Proof with auto.
  intros.
  apply wf_env_drop_label in H.
  rewrite drop_label_reverse_env in H...
  apply wf_env_map_free2 with (B:=bind_sub typ_top)...
Qed.

Lemma drop_wf_env_label_rec: forall E1 X E2 U,
    wf_env (map (subst_tb X (typ_label X (open_tt U X))) E1 ++ (X, bind_sub typ_top) :: E2) ->
    X \notin fv_tt U \u fl_env E1 ->
    WF E2 (typ_mu U) ->
    wf_env ( E1 ++ (X, bind_sub typ_top) :: E2).
Proof with auto.
  intros.
  apply wf_env_drop_label in H.
  rewrite drop_label_reverse_env in H...
Qed.


Lemma binds_map_free_env2: forall E1 E2 X Y U S,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub typ_top) :: E2) ->
    binds X (bind_sub U) (E1 ++ (Y, bind_sub typ_top) :: E2) ->
    binds X (bind_sub (subst_tt Y S U)) (map (subst_tb Y S) E1 ++  E2).
Proof with auto.
  intros.
  analyze_binds H1...
  -
    unfold binds in *.
    apply In_lemmaL.
    apply binds_map_free...
  -
    unfold binds in *.
    apply In_lemmaR.
    rewrite <- maps_subst_tb_free with (X:=Y) (U:=S)...
    apply binds_map_free...
    apply notin_from_wf_env in H0...
Qed.


Lemma binds_subst_extensial_no_subst: forall E S  X0 X U,
    binds X0 (bind_sub U) (map (subst_tb X S) E) ->
    exists A,
      binds X0 (bind_sub A) E.
Proof with auto.
  induction E;intros...
  simpl in *.
  analyze_binds H.
  simpl in *.
  destruct a.
  analyze_binds H.
  -
    destruct b;simpl in *; inversion BindsTacVal.
    exists t...
  -
    apply IHE in BindsTac...
    destruct_hypos.
    exists x...
Qed.


Lemma notin_fl_env: forall E X Y U,
    binds X (bind_sub U) E ->
    Y \notin fl_env E ->
    Y \notin fl_tt U.
Proof with eauto.
  induction E;intros...
  simpl in *.
  destruct a.
  destruct b...
  -
    analyze_binds H.
    inversion BindsTacVal...
    apply IHE with (X:=X)...
  -
    analyze_binds H.
    apply IHE with (X:=X)...
Qed.

Lemma binds_uniq: forall E X A B,
    wf_env E ->
    binds X (bind_sub A) E ->
    binds X (bind_sub B) E ->
    A = B.
Proof with auto.
  induction E;intros...
  analyze_binds H0.
  destruct a.
  analyze_binds_uniq H0.
  -
    apply uniq_from_wf_env...
  -
    analyze_binds_uniq H1...
    inversion BindsTacVal...
  -
    analyze_binds_uniq H1...
    apply IHE with (X:=X)...
    dependent destruction H...
Qed.

Lemma sub_tvar_trans_var: forall X A E B,
    binds X (bind_sub A) E ->
    sub E X B ->
    (typ_fvar X) <> B ->
    sub E A B.
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H0;intros...
  -
    destruct H1...
  -
    constructor...
    apply WF_from_binds_typ with (x:=X)...
  -
    apply  binds_uniq with (A:=A) in H...
    subst...
    get_well_form...
  -
    inversion H0.
Qed.

Lemma open_tt_var_rev: forall A B (X:atom),
    X \notin fv_tt A \u fv_tt B ->
    open_tt A X = open_tt B X ->
    A = B.
Proof with auto.
  unfold open_tt.
  generalize 0.
  intros n A B.
  generalize dependent n.
  generalize dependent B.
  induction A;induction B;intros;simpl in *;try solve [inversion H0|destruct (n0==n);subst;inversion H0]...
  -
    destruct (n1==n);destruct (n1==n0);subst...
    inversion H0.
    inversion H0.
  -
    destruct (n0==n);subst...
    inversion H0.
    rewrite <- H2 in H.
    solve_notin_self X.
  -
    destruct (n0==n);subst...
    inversion H0.
    rewrite  H2 in H.
    solve_notin_self X.
  -
    inversion H0.
    apply IHA1 in H2...
    apply IHA2 in H3...
    subst...
  -
    inversion H0.
    apply IHA1 in H2...
    apply IHA2 in H3...
    subst...
  -
    inversion H0.
    apply IHA in H2...
    subst...
  -
    inversion H0.
    apply IHA in H3...
    subst...
  -
    inversion H0.
    apply IHA1 in H3...
    apply IHA2 in H4...
    subst...
Qed.

Lemma EqDec_eq : forall (A B: typ),
    {A = B} + {A <> B}.
Proof with auto.
  intros.
  decide equality.
  decide equality. 
Qed.  

Lemma mu_transform_0: forall C  (Y X:atom) A ,
    type (typ_mu C) ->
    X <> Y ->
    (subst_tt X (typ_mu C) (open_tt A (typ_label Y (open_tt A Y)))) =
 (open_tt (subst_tt X (typ_mu C) A)
       (typ_label Y (open_tt (subst_tt X (typ_mu C) A) Y))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal.
  simpl...
  f_equal.
  rewrite subst_tt_open_tt_var...
Qed.

Lemma mu_transform_1: forall (X Y:atom) A C,
    X <> Y ->
    type (open_tt C X) ->
    (open_tt (subst_tt X (typ_label X (open_tt C X)) A)
                 (typ_label Y (open_tt (subst_tt X (typ_label X (open_tt C X)) A) Y))) =
    (subst_tt X (typ_label X (open_tt C X)) (open_tt A (typ_label Y (open_tt A Y)))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  destruct (Y==X)...
  destruct H...
Qed.


Lemma union_split: forall A B C,
    union A B [<=] C -> A [<=] C /\ B [<=] C.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  split;intros.
  apply H.
  apply D.F.union_iff...
  apply H.
  apply D.F.union_iff...
Qed.


Lemma label_choose_reserve : forall X A B E,
    WF E B ->
    rt_type B ->
    collectLabel B [=] collectLabel (subst_tt X A B).
Proof with auto.
  intros.
  induction B;simpl;try solve [apply AtomSetProperties.equal_refl]...
  inversion H0.
  dependent destruction H.
  apply KeySetProperties.union_equal_2...
Qed.


Lemma label_equiv: forall E C D,
    equiv E C D ->
    collectLabel C [=] collectLabel D.
Proof with auto.
  intros.
  unfold equiv in *.
  destruct H.
  induction H;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
  -
    dependent destruction H0...
    simpl.
    apply AtomSetProperties.equal_refl.
    inversion H2.
  -
    apply sub_tvar_inv in H0. destruct H0... subst...
    apply AtomSetProperties.equal_refl.
  -
    dependent induction H0;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
    +
      inversion H1.
    +
      inversion H2.
    +
      apply AtomSetProperties.subset_antisym...
Qed.


Lemma label_equiv_reserve : forall X E A B C D ,
    rt_type A -> rt_type B ->
    collectLabel A [<=] collectLabel B ->
    collectLabel C [=] collectLabel D ->
    WF E A -> WF E B ->
    collectLabel (subst_tt X D A) [<=] collectLabel (subst_tt X C B).
Proof with auto.
  intros.
  induction A; try solve [inversion H].
  -
    induction B; try solve [inversion H0].
    simpl...
    simpl...
    apply KeySetProperties.subset_empty...
  -
    induction B; try solve [inversion H0].
    +
      simpl in *.
      apply union_empty in H1.
      destruct H1.
    +
      simpl in *...
      apply union_split in H1.
      destruct H1.
      apply AtomSetProperties.union_subset_3...
      *
        dependent destruction H4.
        rewrite <- label_choose_reserve with (E:=E)...
      *
        dependent destruction H3.
        apply IHA2...
Qed.



Lemma sub_generalize_intensive : forall E1 E2 A B C D X m S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    X \notin fv_tt C \u fv_tt D \u fl_env E1 \u fl_env E2 \u fl_tt A \u fl_tt B \u dom E1 \u dom E2 \u fv_tt S \u fl_tt C \u fl_tt D \u fl_tt S ->
    sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X (open_tt C X)) A) (subst_tt X (typ_label X  (open_tt D X)) B) ->
    sub E2 (typ_mu (choose m C S))  (typ_mu (choose m S C)) ->
    sub E2 (typ_mu (choose m S D))  (typ_mu (choose m D S)) ->
    sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu C) A) (subst_tt X (typ_mu D) B).
Proof with auto.
  intros.
  generalize dependent m.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction H;intros...
  -
    simpl.
    constructor...
    apply subst_tt_wf_env_label_rec...
    get_well_form...
    destruct m;simpl in *;get_well_form...
  -
    simpl in *.
    destruct (X0==X);subst...
    +
      assert (wf_env (empty ++ map (subst_tb X (typ_mu S)) E1 ++ E2)).
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
      apply Sub_weakening...
      destruct m;simpl in *...
      *
        apply sub_transitivity with (Q:=typ_mu S)...
      *
        assert (sub E2 (typ_mu D) (typ_mu C)).
        {
          apply sub_transitivity with (Q:=typ_mu S)...
        }
        dependent destruction H6.
        dependent destruction H2.
        apply sub_strengthening_env in H2...
        --
          pick fresh Y.
          apply equiv_sub_unfolding with (Y:=Y)...
          apply sub_replacing_var with (X:=X)...
          constructor...
          get_well_form...
          specialize_x_and_L Y L.
          apply sub_nominal_inversion in H8...
        --
          constructor...
          get_well_form...
        --
          pick fresh Y.
          apply WF_replacing_var with (X:=Y)...
        --
          pick fresh Y.
          apply WF_replacing_var with (X:=Y)...
        --
          inv_rt.
        --
          inv_rt.
    +
      constructor...
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      assert (typ_fvar X0 = subst_tt X (typ_mu S) (typ_fvar X0)).
      simpl...
      destruct (X0==X);subst...
      destruct n...
      rewrite H5.
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      destruct m;simpl in *;get_well_form...
  -
    simpl.
    constructor...
    apply subst_tt_wf_env_label_rec...
    get_well_form...
    destruct m;simpl in *;get_well_form...
    rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
    apply  WF_narrowing_env with (S:=typ_mu C).
    apply subst_tb_wf with (Q:=bind_sub typ_top)...
    destruct m;simpl in *;get_well_form...
  -
    simpl in *.
    destruct (X0==X);subst...
    +
      analyze_binds_uniq H.
      apply uniq_from_wf_env...
      get_well_form...
      inversion BindsTacVal;subst.
      dependent destruction H0.
      2:{ inv_rt. }
      simpl...
      constructor...
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
      apply  WF_narrowing_env with (S:=typ_mu C).
      apply WF_weakening...
      destruct m;simpl in *;get_well_form...
    +
      destruct ( EqDec_eq T  (typ_fvar X0)).
      *
        induction T;try solve [inversion e].
        rewrite e in *.
        simpl...
        destruct (X0==X);subst...
        destruct n...
        constructor...
        apply subst_tt_wf_env_label_rec...
        get_well_form...
        destruct m;simpl in *;get_well_form...
        apply WF_var with (U:=subst_tt X (typ_mu S) U)...
        apply binds_map_free_env2...
        get_well_form...
      *
        apply sa_trans_tvar with (U:=subst_tt X (typ_mu S) U)...
        --
          apply binds_map_free_env2...
          get_well_form...
        --
          apply IHsub with (m:=m)...
          ++
            solve_notin.
            apply notin_fl_env with (X:=X0) (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            solve_notin.
          ++
            apply sub_tvar_trans_var with (A:=subst_tt X (typ_label X (open_tt S X)) U) in H2...
            **
              apply binds_map_free_env...
              get_well_form...
            **
              induction T;simpl;try solve [intros v;inversion v]...
              destruct (a==X);subst...
              intros v;inversion v.
          ++
            destruct m;simpl in *;apply Reflexivity;get_well_form...
  -
    simpl in *.
    dependent destruction H2.
    constructor...
    +
      apply IHsub1 with (m:=flip m)...
      destruct m;simpl in *...
      destruct m;simpl in *...
    +
      apply IHsub2 with (m:=m)...
    +
      inv_rt.
  -
    simpl in *.
    dependent destruction H4.
    assert (equiv (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2)
                  (subst_tt X (typ_label X (open_tt C X)) S1) (subst_tt X (typ_label X (open_tt D X)) S2)) as HE.
    {
      unfold equiv...
    }
    assert (type4rec S1) as TS1.
    {
      get_type...
      apply type_to_rec in H19...
    }
    assert (type4rec S2) as TS2.
    {
      get_type...
      apply type_to_rec in H20...
    }    
    apply subst_reverse_equiv  with (B:=S2) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S) in TS1...
    +
      destruct TS1.
      *
        assert (equiv E2 (typ_mu C) (typ_mu D)).
          {
            unfold equiv in *.
            destruct_hypos.
            split.
            apply  equiv_sub_unfolding with (Y:=X)...
            apply  equiv_sub_unfolding with (Y:=X)...
          }
          assert (equiv E2 (typ_mu C) (typ_mu S)).
          {
            unfold equiv in *.
            destruct_hypos.
            destruct m;simpl in *.
            split...
            apply sub_transitivity with (Q:=typ_mu D)...
            split...
            apply sub_transitivity with (Q:=typ_mu D)...
          }
          assert (equiv E2 (typ_mu S) (typ_mu D)).
          {
            unfold equiv in *.
            destruct_hypos.
            destruct m;simpl in *.
            split...
            apply sub_transitivity with (Q:=typ_mu C)...
            split...
            apply sub_transitivity with (Q:=typ_mu C)...
          }
        apply sa_all with (L:=L \u L0  \u {{X}});intros...
        --
          apply equiv_sub_subst_not_var...
        --
          apply equiv_sub_subst_not_var;unfold equiv in *;destruct_hypos;try split...
        --
          rewrite subst_tt_open_tt_var...
          rewrite subst_tt_open_tt_var...
          rewrite_env  (nil ++ X0 ~ bind_sub (subst_tt X (typ_mu D) S2) ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
          apply sub_narrowing with (Q:=subst_tt X (typ_mu S) S2)...
          ++
            apply equiv_sub_subst_refl_no_var...
            get_well_form...
            get_well_form...
            unfold equiv in *;destruct_hypos;split;apply sub_transitivity with (Q:=typ_mu C)...
            unfold equiv in *;destruct_hypos;split;apply sub_transitivity with (Q:=typ_mu C)...
            unfold equiv in *;destruct_hypos;split;apply Reflexivity;get_well_form...
          ++
            rewrite_env (map (subst_tb X (typ_mu S)) (X0 ~ bind_sub S2 ++ E1) ++ E2).
            apply H2 with (m:=m)...
            solve_notin.
            rewrite <- subst_tt_open_tt_var...
            rewrite <- subst_tt_open_tt_var...
            rewrite_env (nil ++ X0 ~ bind_sub  (subst_tt X (typ_label X (open_tt S X)) S2) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++
                             (X, bind_sub typ_top) :: E2).
            apply sub_narrowing with (Q:= subst_tt X (typ_label X (open_tt D X)) S2)...
            apply equiv_sub_subst_refl...
            **
              get_well_form...
            **
              get_well_form...
            **
              apply equiv_unfolding...
            **
              apply equiv_unfolding...
              apply equiv_reflexivity;get_well_form...
              destruct m;simpl in *...
            **
              apply equiv_unfolding...
            **
              apply H4...
            **
              unfold equiv in *;destruct_hypos;get_type...
            **
              unfold equiv in *;destruct_hypos;get_type...
          ++
            unfold equiv in *;get_well_form;destruct_hypos;get_type...
          ++
            unfold equiv in *;get_well_form;destruct_hypos;get_type...
      *
        assert (subst_tt X (typ_mu C) S1 = subst_tt X (typ_mu S) S1) as HS1.
        {
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
          }
        assert (subst_tt X (typ_mu D) S2 = subst_tt X (typ_mu S) S2) as HS2.
        {
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
        }
        rewrite HS1.
        rewrite HS2.
        assert (equiv E2 (typ_mu S) (typ_mu S)).
        {
          unfold equiv;split;apply Reflexivity;get_well_form;auto;
            destruct m;simpl in *...
        }          
        apply sa_all with (L:=L \u L0  \u {{X}});intros...
        --
          apply equiv_sub_subst_not_var...
        --         
          apply equiv_sub_subst_not_var...
        --
          assert (type (typ_mu D)).
          destruct m;simpl in *;get_type...
          assert (type (typ_mu C)).
          destruct m;simpl in *;get_type...
          rewrite subst_tt_open_tt_var...
          rewrite subst_tt_open_tt_var...
          rewrite_env  ( map (subst_tb X (typ_mu S)) (X0 ~ bind_sub S2 ++ E1) ++ E2).
          apply H2 with (m:=m)...
          solve_notin.
          rewrite <- subst_tt_open_tt_var...
          rewrite <- subst_tt_open_tt_var...
          rewrite_env (X0 ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) S2) ++
                          map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
          assert (subst_tt X (typ_label X (open_tt S X)) S2 = subst_tt X (typ_label X (open_tt D X)) S2) as HS.
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite HS...
          ++
            dependent destruction H10.
            constructor...
            pick fresh Y.
            rewrite subst_tt_intro with (X:=Y)...
            apply subst_tt_type...
          ++
            dependent destruction H11.
            constructor...
            pick fresh Y.
            rewrite subst_tt_intro with (X:=Y)...
            apply subst_tt_type...
    +
      unfold equiv;split...
    +
      assert (WF E2 (typ_mu C)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      assert (WF E2 (typ_mu D)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      assert (WF E2 (typ_mu S)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      get_well_form...
    +
      inv_rt.
  -
    simpl in *.
    dependent destruction H4.
    apply sa_rec with (L:=L \u L0 \u {{X}} \u fv_tt C \u fv_tt D   \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) (X0~bind_sub typ_top ++ E1) ++ E2).
      apply WF_narrowing_env with (S:=typ_mu C)...
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      apply H...
      destruct m;simpl;get_well_form...
      destruct m;simpl;get_type...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) (X0~bind_sub typ_top ++ E1) ++ E2).
      apply WF_narrowing_env with (S:=typ_mu D)...
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      apply H0...
      destruct m;simpl;get_well_form...
      destruct m;simpl;get_type...
    +
      assert (type (typ_mu C) /\ type (typ_mu D)).
      split;destruct m;simpl in *;get_type...
      destruct_hypos.
      rename X0 into Y.
      rewrite_env (map (subst_tb X (typ_mu S)) (Y~bind_sub typ_top ++ E1) ++ E2).
      rewrite <- mu_transform_0...
      rewrite <- mu_transform_0...
      apply H2 with (X1:=X) (X0:=Y) (m:=m)...
      *
        solve_notin.
      *
        rewrite <- mu_transform_1...
        rewrite <- mu_transform_1...
        apply H6...
        dependent destruction H11.
        pick fresh Z.
        rewrite subst_tt_intro with (X:=Z)...
        apply subst_tt_type...
        dependent destruction H10.
        pick fresh Z.
        rewrite subst_tt_intro with (X:=Z)...
        apply subst_tt_type...
    + inv_rt.
  -
    simpl in *.
    dependent destruction H1.
    +
      constructor...
      apply IHsub with (m:=m)...
    +
      inv_rt.
  -
    assert (Hwf1: WF (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu C) A1)).
    {
      get_well_form... add_nil.
      apply WF_narrowing_env with (S:=typ_mu C)...
      eapply subst_tb_wf with (Q:=bind_sub typ_top). destruct m...
      destruct m...
    }
    assert (Hwf2: WF (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu D) A2)).
    {
      get_well_form... add_nil.
      apply WF_narrowing_env with (S:=typ_mu D)...
      eapply subst_tb_wf with (Q:=bind_sub typ_top)... destruct m...
    }
    apply sa_rcd...
    + get_well_form... apply wf_env_map_free2 with (B:=bind_sub typ_top)...
      destruct m...
    + get_well_form.
      destruct m;apply Infrastructure.subst_tt_rt_type;get_type...
    + get_well_form.
      destruct m;apply Infrastructure.subst_tt_rt_type;get_type...
    + 
      apply  label_equiv_reserve with (E:=(E1 ++ [(X, bind_sub typ_top)] ++ E2))...
      simpl. 
      apply AtomSetProperties.equal_refl...
    +
      intros.
      apply Tlookup_subst in H11... 2: get_type...
      apply Tlookup_subst in H12... 2: get_type...
      destruct H11 as [t1'].
      destruct H12 as [t2'].
      destruct_hypos. subst.
      specialize (H6 i _ _ H16 H14 _ _ _ JMeq_refl S D C).
      simpl in *.
      apply H6 with (m:=m)...
      { apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H16...
        apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H14...
        solve_notin.
        * intros c. apply H16 in c. apply H7. 
          repeat (apply D.F.union_iff;auto;right).
        * intros c. apply H14 in c. apply H7.
          repeat (apply D.F.union_iff;auto;right).
      }
      (* apply open_twice_to_one in H8...
      rewrite drop_label_reverse_env in H8...
      rewrite drop_label_reverse_type in H8...
      rewrite drop_label_reverse_type in H8... *)
      apply rcd_inversion with (i:=i) 
        (t1:=(subst_tt X (typ_label X (open_tt C X)) t1')) 
        (t2:=(subst_tt X (typ_label X (open_tt D X)) t2')) in H8...
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X ~ bind_sub typ_top) ++ E2))...
        assert (WF E2 (typ_mu C)) by (destruct m;get_well_form;auto).
        dependent destruction H13.
        pick fresh Y. constructor.
        add_nil. apply WF_weakening...
        apply WF_replacing_var with (X:=Y)...
      }
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X ~ bind_sub typ_top) ++ E2))...
        assert (WF E2 (typ_mu D)) by (destruct m;get_well_form;auto).
        dependent destruction H13.
        pick fresh Y. constructor.
        add_nil. apply WF_weakening...
        apply WF_replacing_var with (X:=Y)...
      }
      { apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))... }
      { apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))... }
Qed.
    
Lemma sub_generalize_unfolding : forall E1 E2 A B C D X  S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    X \notin fv_tt C \u fv_tt D \u fl_env E1 \u fl_env E2 \u fl_tt A \u fl_tt B \u dom E1 \u dom E2 \u fv_tt S \u fl_tt C \u fl_tt D \u fl_tt S ->
    sub E2 (typ_mu C)  (typ_mu S) ->
    sub E2 (typ_mu S)  (typ_mu D) ->
    (sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X  (open_tt C X)) A) (subst_tt X (typ_label X (open_tt D X)) B) ->
     sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X  (typ_mu C) A) (subst_tt X (typ_mu D) B)) /\ (sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X  (open_tt D X)) A) (subst_tt X (typ_label X (open_tt C X)) B) ->
     sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X  (typ_mu D) A) (subst_tt X (typ_mu C) B)).    
Proof with auto.   
  intros.
  split;intros.
  apply sub_generalize_intensive with (m:=Pos) (C:=C) (D:=D) (S:=S) in H ...
  apply sub_generalize_intensive with (m:=Neg) (C:=D) (D:=C) (S:=S) in H ...
Qed.  

  
Lemma unfolding_lemma: forall E A B,
    sub E (typ_mu A) (typ_mu B) ->
    sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction H.
  pick fresh X.
  rewrite subst_tt_intro with (X:=X)...
  remember (subst_tt X (typ_mu A) (open_tt A X)) .
  rewrite subst_tt_intro with (X:=X)...
  subst.
  rewrite_env (map (subst_tb X (typ_mu B)) nil ++ E).
  apply sub_generalize_intensive with (m:=Pos)...
  -
    specialize_x_and_L X L.
    apply sub_nominal_inversion in H1...
  -
    solve_notin.
  -
    simpl.
    rewrite <- subst_tt_intro...
    rewrite <- subst_tt_intro...
    apply H1...
  -
    get_well_form.
    apply Reflexivity...
  -
    inv_rt.
Qed.
