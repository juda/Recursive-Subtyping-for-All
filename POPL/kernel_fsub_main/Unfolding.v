Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Reverse.
            

Lemma choose_flip: forall m A B ,
    choose m A B = choose (flip m) B A .
Proof with auto.
  intros.
  destruct m...
Qed.


  
Lemma subst_tt_wf_env_label_rec: forall E1 X E2 U,
    wf_env (map (subst_tb X (typ_label X (open_tt U X))) E1 ++ (X, bind_sub typ_top) :: E2) ->
    X \notin fv_tt U \u fl_env E1 ->
    WF E2 (typ_mu U) ->
    wf_env (map (subst_tb X (typ_mu U)) E1 ++ E2).
Proof with auto.
  intros.
  apply wf_env_drop_label in H.
  rewrite drop_label_reverse_env in H...
  apply wf_env_map_free2 with (B:=bind_sub typ_top)...
Qed.

Lemma drop_wf_env_label_rec: forall E1 X E2 U,
    wf_env (map (subst_tb X (typ_label X (open_tt U X))) E1 ++ (X, bind_sub typ_top) :: E2) ->
    X \notin fv_tt U \u fl_env E1 ->
    WF E2 (typ_mu U) ->
    wf_env ( E1 ++ (X, bind_sub typ_top) :: E2).
Proof with auto.
  intros.
  apply wf_env_drop_label in H.
  rewrite drop_label_reverse_env in H...
Qed.


Lemma binds_map_free_env2: forall E1 E2 X Y U S,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub typ_top) :: E2) ->
    binds X (bind_sub U) (E1 ++ (Y, bind_sub typ_top) :: E2) ->
    binds X (bind_sub (subst_tt Y S U)) (map (subst_tb Y S) E1 ++  E2).
Proof with auto.
  intros.
  analyze_binds H1...
  -
    unfold binds in *.
    apply In_lemmaL.
    apply binds_map_free...
  -
    unfold binds in *.
    apply In_lemmaR.
    rewrite <- maps_subst_tb_free with (X:=Y) (U:=S)...
    apply binds_map_free...
    apply notin_from_wf_env in H0...
Qed.


Lemma binds_subst_extensial_no_subst: forall E S  X0 X U,
    binds X0 (bind_sub U) (map (subst_tb X S) E) ->
    exists A,
      binds X0 (bind_sub A) E.
Proof with auto.
  induction E;intros...
  simpl in *.
  analyze_binds H.
  simpl in *.
  destruct a.
  analyze_binds H.
  -
    destruct b;simpl in *; inversion BindsTacVal.
    exists t...
  -
    apply IHE in BindsTac...
    destruct_hypos.
    exists x...
Qed.

(* 
Lemma subst_tb_wf_reverse: forall S X T E Q E2,
  WF (map (subst_tb X T) E ++ X ~ bind_sub Q ++E2) (subst_tt X T S) ->
  WF (X ~ bind_sub Q ++E2) T ->
  WF (E ++ X ~ bind_sub Q ++ E2) S.
Proof with eauto.
  intros.
  dependent induction H;simpl in *;try solve [dependent destruction H;eauto]...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    rewrite <- x.
    analyze_binds H...
    apply binds_subst_extensial_no_subst in BindsTac...
    destruct_hypos...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    dependent destruction x.
    constructor...    
  -
    induction S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    dependent destruction x...
    clear IHS1 IHS2.
    apply WF_all with (L:=L \u {{X}});intros...
    rewrite_env ((X0 ~ bind_sub S1 ++ E) ++ (X, bind_sub Q) :: E2).
    apply H1 with (X0:=X0) (T0:=T)...
    rewrite subst_tt_open_tt_var...
    get_type...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    dependent destruction x...
    apply WF_rec with (L:=L \u {{X}});intros...
    +
      rewrite_env ((X0 ~ bind_sub typ_top ++ E) ++ (X, bind_sub Q) :: E2).
      apply H0 with (X0:=X0) (T0:=T)...
      rewrite subst_tt_open_tt_var...
      get_type...
    +
      rewrite_env ((X0 ~ bind_sub typ_top ++ E) ++ (X, bind_sub Q) :: E2).
      apply H2 with (X0:=X0) (T0:=T)...
      rewrite subst_tt_open_tt_twice...
      get_type...      
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    constructor...
    apply IHWF with (T0:=T)...
    inversion x...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
  -
    destruct S;simpl in *;try solve [inversion x]...
    destruct (a==X);try solve [inversion x]...
    inversion x;subst.
    constructor...
    { destruct S2;simpl in *; try solve [inversion H1]...
      destruct (a0==X);try solve [inversion H1]... subst. Search subst_tt rt_type. apply subst_tt_rt_type. in H1... }
    apply IHWF1 with (T0:=T)...
    inversion x...
Qed. *)

(* Lemma subst_tb_wf_env_reverse: forall E E2 X T,
    wf_env (map (subst_tb X T) E ++ (X~ bind_sub typ_top) ++ E2) ->
    WF ((X~ bind_sub typ_top) ++ E2) T ->
    wf_env (E ++ (X~ bind_sub typ_top) ++ E2).
Proof with auto.
  induction E;intros...
  destruct a.
  destruct b.
  -
    simpl in *.
    dependent destruction H...    
    constructor...
    apply IHE with (T:=T)...
    apply subst_tb_wf_reverse in H0...
  -
    simpl in *.
    dependent destruction H...    
    constructor...
    apply IHE with (T:=T)...
    apply subst_tb_wf_reverse in H0...
Qed. *)
 

Lemma notin_fl_env: forall E X Y U,
    binds X (bind_sub U) E ->
    Y \notin fl_env E ->
    Y \notin fl_tt U.
Proof with eauto.
  induction E;intros...
  simpl in *.
  destruct a.
  destruct b...
  -
    analyze_binds H.
    inversion BindsTacVal...
    apply IHE with (X:=X)...
  -
    analyze_binds H.
    apply IHE with (X:=X)...
Qed.

Lemma binds_uniq: forall E X A B,
    wf_env E ->
    binds X (bind_sub A) E ->
    binds X (bind_sub B) E ->
    A = B.
Proof with auto.
  induction E;intros...
  analyze_binds H0.
  destruct a.
  analyze_binds_uniq H0.
  -
    apply uniq_from_wf_env...
  -
    analyze_binds_uniq H1...
    inversion BindsTacVal...
  -
    analyze_binds_uniq H1...
    apply IHE with (X:=X)...
    dependent destruction H...
Qed.

Lemma sub_tvar_trans_var: forall X A E B,
    binds X (bind_sub A) E ->
    sub E X B ->
    (typ_fvar X) <> B ->
    sub E A B.
Proof with auto.
  intros.
  generalize dependent A.
  dependent induction H0;intros...
  -
    destruct H1...
  -
    constructor...
    apply WF_from_binds_typ with (x:=X)...
  -
    apply  binds_uniq with (A:=A) in H...
    subst...
    get_well_form...
  -
    inversion H0.
Qed.

Lemma open_tt_var_rev: forall A B (X:atom),
    X \notin fv_tt A \u fv_tt B ->
    open_tt A X = open_tt B X ->
    A = B.
Proof with auto.
  unfold open_tt.
  generalize 0.
  intros n A B.
  generalize dependent n.
  generalize dependent B.
  induction A;induction B;intros;simpl in *;try solve [inversion H0|destruct (n0==n);subst;inversion H0]...
  -
    destruct (n1==n);destruct (n1==n0);subst...
    inversion H0.
    inversion H0.
  -
    destruct (n0==n);subst...
    inversion H0.
    rewrite <- H2 in H.
    solve_notin_self X.
  -
    destruct (n0==n);subst...
    inversion H0.
    rewrite  H2 in H.
    solve_notin_self X.
  -
    inversion H0.
    apply IHA1 in H2...
    apply IHA2 in H3...
    subst...
  -
    inversion H0.
    apply IHA1 in H2...
    apply IHA2 in H3...
    subst...
  -
    inversion H0.
    apply IHA in H2...
    subst...
  -
    inversion H0.
    apply IHA in H3...
    subst...
  -
    inversion H0.
    apply IHA1 in H3...
    apply IHA2 in H4...
    subst...
Qed.

Lemma EqDec_eq : forall (A B: typ),
    {A = B} + {A <> B}.
Proof with auto.
  intros.
  decide equality.
  decide equality. 
Qed.  

Lemma mu_transform_0: forall C  (Y X:atom) A ,
    type (typ_mu C) ->
    X <> Y ->
    (subst_tt X (typ_mu C) (open_tt A (typ_label Y (open_tt A Y)))) =
 (open_tt (subst_tt X (typ_mu C) A)
       (typ_label Y (open_tt (subst_tt X (typ_mu C) A) Y))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal.
  simpl...
  f_equal.
  rewrite subst_tt_open_tt_var...
Qed.

Lemma mu_transform_1: forall (X Y:atom) A C,
    X <> Y ->
    type (open_tt C X) ->
    (open_tt (subst_tt X (typ_label X (open_tt C X)) A)
                 (typ_label Y (open_tt (subst_tt X (typ_label X (open_tt C X)) A) Y))) =
    (subst_tt X (typ_label X (open_tt C X)) (open_tt A (typ_label Y (open_tt A Y)))).
Proof with auto.
  intros.
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  f_equal...
  rewrite subst_tt_open_tt...
  f_equal...
  simpl...
  destruct (Y==X)...
  destruct H...
Qed.


Lemma union_split: forall A B C,
    union A B [<=] C -> A [<=] C /\ B [<=] C.
Proof with auto.
  intros.
  unfold "[<=]" in *.
  split;intros.
  apply H.
  apply D.F.union_iff...
  apply H.
  apply D.F.union_iff...
Qed.


Lemma label_choose_reserve : forall X A B E,
    WF E B ->
    rt_type B ->
    collectLabel B [=] collectLabel (subst_tt X A B).
Proof with auto.
  intros.
  induction B;simpl;try solve [apply AtomSetProperties.equal_refl]...
  inversion H0.
  dependent destruction H.
  apply KeySetProperties.union_equal_2...
Qed.


Lemma label_equiv: forall E C D,
    equiv E C D ->
    collectLabel C [=] collectLabel D.
Proof with auto.
  intros.
  unfold equiv in *.
  destruct H.
  induction H;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
  -
    dependent destruction H0...
    simpl.
    apply AtomSetProperties.equal_refl.
    inversion H2.
  -
    apply sub_tvar_inv in H0. destruct H0... subst...
    apply AtomSetProperties.equal_refl.
  -
    dependent induction H0;simpl in *;try solve [apply AtomSetProperties.equal_refl]...
    +
      inversion H1.
    +
      inversion H2.
    +
      apply AtomSetProperties.subset_antisym...
Qed.


Lemma label_equiv_reserve : forall X E A B C D ,
    rt_type A -> rt_type B ->
    collectLabel A [<=] collectLabel B ->
    collectLabel C [=] collectLabel D ->
    WF E A -> WF E B ->
    collectLabel (subst_tt X D A) [<=] collectLabel (subst_tt X C B).
Proof with auto.
  intros.
  induction A; try solve [inversion H].
  -
    induction B; try solve [inversion H0].
    simpl...
    simpl...
    apply KeySetProperties.subset_empty...
  -
    induction B; try solve [inversion H0].
    +
      simpl in *.
      apply union_empty in H1.
      destruct H1.
    +
      simpl in *...
      apply union_split in H1.
      destruct H1.
      apply AtomSetProperties.union_subset_3...
      *
        dependent destruction H4.
        rewrite <- label_choose_reserve with (E:=E)...
      *
        dependent destruction H3.
        apply IHA2...
Qed.



Lemma sub_generalize_intensive : forall E1 E2 A B C D X m S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    X \notin fv_tt C \u fv_tt D \u fl_env E1 \u fl_env E2 \u fl_tt A \u fl_tt B \u dom E1 \u dom E2 \u fv_tt S \u fl_tt C \u fl_tt D \u fl_tt S ->
    sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X (open_tt C X)) A) (subst_tt X (typ_label X  (open_tt D X)) B) ->
    sub E2 (typ_mu (choose m C S))  (typ_mu (choose m S C)) ->
    sub E2 (typ_mu (choose m S D))  (typ_mu (choose m D S)) ->
    sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu C) A) (subst_tt X (typ_mu D) B).
Proof with auto.
  intros.
  generalize dependent m.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction H;intros...
  -
    simpl.
    constructor...
    apply subst_tt_wf_env_label_rec...
    get_well_form...
    destruct m;simpl in *;get_well_form...
  -
    simpl in *.
    destruct (X0==X);subst...
    +
      assert (wf_env (empty ++ map (subst_tb X (typ_mu S)) E1 ++ E2)).
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
      apply Sub_weakening...
      destruct m;simpl in *...
      *
        apply sub_transitivity with (Q:=typ_mu S)...
      *
        assert (sub E2 (typ_mu D) (typ_mu C)).
        {
          apply sub_transitivity with (Q:=typ_mu S)...
        }
        dependent destruction H6.
        dependent destruction H2.
        apply sub_strengthening_env in H2...
        --
          pick fresh Y.
          apply equiv_sub_unfolding with (Y:=Y)...
          apply sub_replacing_var with (X:=X)...
          constructor...
          get_well_form...
          specialize_x_and_L Y L.
          apply sub_nominal_inversion in H8...
        --
          constructor...
          get_well_form...
        --
          pick fresh Y.
          apply WF_replacing_var with (X:=Y)...
        --
          pick fresh Y.
          apply WF_replacing_var with (X:=Y)...
        --
          inv_rt.
        --
          inv_rt.
    +
      constructor...
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      assert (typ_fvar X0 = subst_tt X (typ_mu S) (typ_fvar X0)).
      simpl...
      destruct (X0==X);subst...
      destruct n...
      rewrite H5.
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      destruct m;simpl in *;get_well_form...
  -
    simpl.
    constructor...
    apply subst_tt_wf_env_label_rec...
    get_well_form...
    destruct m;simpl in *;get_well_form...
    rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
    apply  WF_narrowing_env with (S:=typ_mu C).
    apply subst_tb_wf with (Q:=bind_sub typ_top)...
    destruct m;simpl in *;get_well_form...
  -
    simpl in *.
    destruct (X0==X);subst...
    +
      analyze_binds_uniq H.
      apply uniq_from_wf_env...
      get_well_form...
      inversion BindsTacVal;subst.
      dependent destruction H0.
      2:{ inv_rt. }
      simpl...
      constructor...
      apply subst_tt_wf_env_label_rec...
      get_well_form...
      destruct m;simpl in *;get_well_form...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
      apply  WF_narrowing_env with (S:=typ_mu C).
      apply WF_weakening...
      destruct m;simpl in *;get_well_form...
    +
      destruct ( EqDec_eq T  (typ_fvar X0)).
      *
        induction T;try solve [inversion e].
        rewrite e in *.
        simpl...
        destruct (X0==X);subst...
        destruct n...
        constructor...
        apply subst_tt_wf_env_label_rec...
        get_well_form...
        destruct m;simpl in *;get_well_form...
        apply WF_var with (U:=subst_tt X (typ_mu S) U)...
        apply binds_map_free_env2...
        get_well_form...
      *
        apply sa_trans_tvar with (U:=subst_tt X (typ_mu S) U)...
        --
          apply binds_map_free_env2...
          get_well_form...
        --
          apply IHsub with (m:=m)...
          ++
            solve_notin.
            apply notin_fl_env with (X:=X0) (E:=E1 ++ (X, bind_sub typ_top) :: E2)...
            solve_notin.
          ++
            apply sub_tvar_trans_var with (A:=subst_tt X (typ_label X (open_tt S X)) U) in H2...
            **
              apply binds_map_free_env...
              get_well_form...
            **
              induction T;simpl;try solve [intros v;inversion v]...
              destruct (a==X);subst...
              intros v;inversion v.
          ++
            destruct m;simpl in *;apply Reflexivity;get_well_form...
  -
    simpl in *.
    dependent destruction H2.
    constructor...
    +
      apply IHsub1 with (m:=flip m)...
      destruct m;simpl in *...
      destruct m;simpl in *...
    +
      apply IHsub2 with (m:=m)...
    +
      inv_rt.
  -
    simpl in *.
    dependent destruction H4.
    assert (equiv (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2)
                  (subst_tt X (typ_label X (open_tt C X)) S1) (subst_tt X (typ_label X (open_tt D X)) S2)) as HE.
    {
      unfold equiv...
    }
    assert (type4rec S1) as TS1.
    {
      get_type...
      apply type_to_rec in H19...
    }
    assert (type4rec S2) as TS2.
    {
      get_type...
      apply type_to_rec in H20...
    }    
    apply subst_reverse_equiv  with (B:=S2) (X:=X) (C:=C) (D:=D) (E1:=E1) (E2:=E2) (S:=S) in TS1...
    +
      destruct TS1.
      *
        assert (equiv E2 (typ_mu C) (typ_mu D)).
          {
            unfold equiv in *.
            destruct_hypos.
            split.
            apply  equiv_sub_unfolding with (Y:=X)...
            apply  equiv_sub_unfolding with (Y:=X)...
          }
          assert (equiv E2 (typ_mu C) (typ_mu S)).
          {
            unfold equiv in *.
            destruct_hypos.
            destruct m;simpl in *.
            split...
            apply sub_transitivity with (Q:=typ_mu D)...
            split...
            apply sub_transitivity with (Q:=typ_mu D)...
          }
          assert (equiv E2 (typ_mu S) (typ_mu D)).
          {
            unfold equiv in *.
            destruct_hypos.
            destruct m;simpl in *.
            split...
            apply sub_transitivity with (Q:=typ_mu C)...
            split...
            apply sub_transitivity with (Q:=typ_mu C)...
          }
        apply sa_all with (L:=L \u L0  \u {{X}});intros...
        --
          apply equiv_sub_subst_not_var...
        --
          apply equiv_sub_subst_not_var;unfold equiv in *;destruct_hypos;try split...
        --
          rewrite subst_tt_open_tt_var...
          rewrite subst_tt_open_tt_var...
          rewrite_env  (nil ++ X0 ~ bind_sub (subst_tt X (typ_mu D) S2) ++ map (subst_tb X (typ_mu S)) E1 ++ E2).
          apply sub_narrowing with (Q:=subst_tt X (typ_mu S) S2)...
          ++
            apply equiv_sub_subst_refl_no_var...
            get_well_form...
            get_well_form...
            unfold equiv in *;destruct_hypos;split;apply sub_transitivity with (Q:=typ_mu C)...
            unfold equiv in *;destruct_hypos;split;apply sub_transitivity with (Q:=typ_mu C)...
            unfold equiv in *;destruct_hypos;split;apply Reflexivity;get_well_form...
          ++
            rewrite_env (map (subst_tb X (typ_mu S)) (X0 ~ bind_sub S2 ++ E1) ++ E2).
            apply H2 with (m:=m)...
            solve_notin.
            rewrite <- subst_tt_open_tt_var...
            rewrite <- subst_tt_open_tt_var...
            rewrite_env (nil ++ X0 ~ bind_sub  (subst_tt X (typ_label X (open_tt S X)) S2) ++ map (subst_tb X (typ_label X (open_tt S X))) E1 ++
                             (X, bind_sub typ_top) :: E2).
            apply sub_narrowing with (Q:= subst_tt X (typ_label X (open_tt D X)) S2)...
            apply equiv_sub_subst_refl...
            **
              get_well_form...
            **
              get_well_form...
            **
              apply equiv_unfolding...
            **
              apply equiv_unfolding...
              apply equiv_reflexivity;get_well_form...
              destruct m;simpl in *...
            **
              apply equiv_unfolding...
            **
              apply H4...
            **
              unfold equiv in *;destruct_hypos;get_type...
            **
              unfold equiv in *;destruct_hypos;get_type...
          ++
            unfold equiv in *;get_well_form;destruct_hypos;get_type...
          ++
            unfold equiv in *;get_well_form;destruct_hypos;get_type...
      *
        assert (subst_tt X (typ_mu C) S1 = subst_tt X (typ_mu S) S1) as HS1.
        {
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
          }
        assert (subst_tt X (typ_mu D) S2 = subst_tt X (typ_mu S) S2) as HS2.
        {
          rewrite <- subst_tt_fresh...
          rewrite <- subst_tt_fresh...
        }
        rewrite HS1.
        rewrite HS2.
        assert (equiv E2 (typ_mu S) (typ_mu S)).
        {
          unfold equiv;split;apply Reflexivity;get_well_form;auto;
            destruct m;simpl in *...
        }          
        apply sa_all with (L:=L \u L0  \u {{X}});intros...
        --
          apply equiv_sub_subst_not_var...
        --         
          apply equiv_sub_subst_not_var...
        --
          assert (type (typ_mu D)).
          destruct m;simpl in *;get_type...
          assert (type (typ_mu C)).
          destruct m;simpl in *;get_type...
          rewrite subst_tt_open_tt_var...
          rewrite subst_tt_open_tt_var...
          rewrite_env  ( map (subst_tb X (typ_mu S)) (X0 ~ bind_sub S2 ++ E1) ++ E2).
          apply H2 with (m:=m)...
          solve_notin.
          rewrite <- subst_tt_open_tt_var...
          rewrite <- subst_tt_open_tt_var...
          rewrite_env (X0 ~ bind_sub (subst_tt X (typ_label X (open_tt S X)) S2) ++
                          map (subst_tb X (typ_label X (open_tt S X))) E1 ++ (X, bind_sub typ_top) :: E2).
          assert (subst_tt X (typ_label X (open_tt S X)) S2 = subst_tt X (typ_label X (open_tt D X)) S2) as HS.
          {
            rewrite <- subst_tt_fresh...
            rewrite <- subst_tt_fresh...
          }
          rewrite HS...
          ++
            dependent destruction H10.
            constructor...
            pick fresh Y.
            rewrite subst_tt_intro with (X:=Y)...
            apply subst_tt_type...
          ++
            dependent destruction H11.
            constructor...
            pick fresh Y.
            rewrite subst_tt_intro with (X:=Y)...
            apply subst_tt_type...
    +
      unfold equiv;split...
    +
      assert (WF E2 (typ_mu C)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      assert (WF E2 (typ_mu D)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      assert (WF E2 (typ_mu S)).
      destruct m;simpl in *;get_well_form...
      dependent destruction H7...
      pick fresh Y.
      apply WF_replacing_var with (X:=Y)...
    +
      get_well_form...
    +
      inv_rt.
  -
    simpl in *.
    dependent destruction H4.
    apply sa_rec with (L:=L \u L0 \u {{X}} \u fv_tt C \u fv_tt D   \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) (X0~bind_sub typ_top ++ E1) ++ E2).
      apply WF_narrowing_env with (S:=typ_mu C)...
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      apply H...
      destruct m;simpl;get_well_form...
      destruct m;simpl;get_type...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ map (subst_tb X (typ_mu S)) (X0~bind_sub typ_top ++ E1) ++ E2).
      apply WF_narrowing_env with (S:=typ_mu D)...
      apply subst_tb_wf with (Q:=bind_sub typ_top)...
      apply H0...
      destruct m;simpl;get_well_form...
      destruct m;simpl;get_type...
    +
      assert (type (typ_mu C) /\ type (typ_mu D)).
      split;destruct m;simpl in *;get_type...
      destruct_hypos.
      rename X0 into Y.
      rewrite_env (map (subst_tb X (typ_mu S)) (Y~bind_sub typ_top ++ E1) ++ E2).
      rewrite <- mu_transform_0...
      rewrite <- mu_transform_0...
      apply H2 with (X1:=X) (X0:=Y) (m:=m)...
      *
        solve_notin.
      *
        rewrite <- mu_transform_1...
        rewrite <- mu_transform_1...
        apply H6...
        dependent destruction H11.
        pick fresh Z.
        rewrite subst_tt_intro with (X:=Z)...
        apply subst_tt_type...
        dependent destruction H10.
        pick fresh Z.
        rewrite subst_tt_intro with (X:=Z)...
        apply subst_tt_type...
    + inv_rt.
  -
    simpl in *.
    dependent destruction H1.
    +
      constructor...
      apply IHsub with (m:=m)...
    +
      inv_rt.
  -
    assert (Hwf1: WF (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu C) A1)).
    {
      get_well_form... add_nil.
      apply WF_narrowing_env with (S:=typ_mu C)...
      eapply subst_tb_wf with (Q:=bind_sub typ_top)... destruct m...
    }
    assert (Hwf2: WF (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X (typ_mu D) A2)).
    {
      get_well_form... add_nil.
      apply WF_narrowing_env with (S:=typ_mu D)...
      eapply subst_tb_wf with (Q:=bind_sub typ_top)... destruct m...
    }
    apply sa_rcd...
    + get_well_form... apply wf_env_map_free2 with (B:=bind_sub typ_top)...
      destruct m...
    + get_well_form.
      destruct m;apply Infrastructure.subst_tt_rt_type;get_type...
    + get_well_form.
      destruct m;apply Infrastructure.subst_tt_rt_type;get_type...
    + 
      apply  label_equiv_reserve with (E:=(E1 ++ [(X, bind_sub typ_top)] ++ E2))...
      simpl. 
      apply AtomSetProperties.equal_refl...
    +
      intros.
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H11...
      apply Tlookup_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H12...
      destruct H11 as [t1'].
      destruct H12 as [t2'].
      destruct_hypos. subst.
      specialize (H6 i _ _ H16 H14 _ _ _ JMeq_refl S D C).
      simpl in *.
      apply H6 with (m:=m)...
      { apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H16...
        apply lookup_some_in_fl_tt with (E:=(E1 ++ (X, bind_sub typ_top) :: E2)) in H14...
        solve_notin.
        * intros c. apply H16 in c. apply H7. 
          repeat (apply D.F.union_iff;auto;right).
        * intros c. apply H14 in c. apply H7.
          repeat (apply D.F.union_iff;auto;right).
      }
      (* apply open_twice_to_one in H8...
      rewrite drop_label_reverse_env in H8...
      rewrite drop_label_reverse_type in H8...
      rewrite drop_label_reverse_type in H8... *)
      apply rcd_inversion with (i:=i) 
        (t1:=(subst_tt X (typ_label X (open_tt C X)) t1')) 
        (t2:=(subst_tt X (typ_label X (open_tt D X)) t2')) in H8...
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X ~ bind_sub typ_top) ++ E2))...
        assert (WF E2 (typ_mu C)) by (destruct m;get_well_form;auto).
        dependent destruction H13.
        pick fresh Y. constructor.
        add_nil. apply WF_weakening...
        apply WF_replacing_var with (X:=Y)...
      }
      {
        apply subst_tt_rt_type with (E:=(E1 ++ (X ~ bind_sub typ_top) ++ E2))...
        assert (WF E2 (typ_mu D)) by (destruct m;get_well_form;auto).
        dependent destruction H13.
        pick fresh Y. constructor.
        add_nil. apply WF_weakening...
        apply WF_replacing_var with (X:=Y)...
      }
      { apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))... }
      { apply lookup_some_subst with (E:=(E1 ++ (X, bind_sub typ_top) :: E2))... }
Qed.
    
Lemma sub_generalize_unfolding : forall E1 E2 A B C D X  S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    X \notin fv_tt C \u fv_tt D \u fl_env E1 \u fl_env E2 \u fl_tt A \u fl_tt B \u dom E1 \u dom E2 \u fv_tt S \u fl_tt C \u fl_tt D \u fl_tt S ->
    sub E2 (typ_mu C)  (typ_mu S) ->
    sub E2 (typ_mu S)  (typ_mu D) ->
    (sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X  (open_tt C X)) A) (subst_tt X (typ_label X (open_tt D X)) B) ->
     sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X  (typ_mu C) A) (subst_tt X (typ_mu D) B)) /\ (sub (map (subst_tb X (typ_label X (open_tt S X))) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X (typ_label X  (open_tt D X)) A) (subst_tt X (typ_label X (open_tt C X)) B) ->
     sub (map (subst_tb X (typ_mu S)) E1 ++ E2) (subst_tt X  (typ_mu D) A) (subst_tt X (typ_mu C) B)).    
Proof with auto.   
  intros.
  split;intros.
  apply sub_generalize_intensive with (m:=Pos) (C:=C) (D:=D) (S:=S) in H ...
  apply sub_generalize_intensive with (m:=Neg) (C:=D) (D:=C) (S:=S) in H ...
Qed.  

  
Lemma unfolding_lemma: forall E A B,
    sub E (typ_mu A) (typ_mu B) ->
    sub E (open_tt A (typ_mu A)) (open_tt B (typ_mu B)).
Proof with auto.
  intros.
  assert (Ht:=H).
  dependent destruction H.
  pick fresh X.
  rewrite subst_tt_intro with (X:=X)...
  remember (subst_tt X (typ_mu A) (open_tt A X)) .
  rewrite subst_tt_intro with (X:=X)...
  subst.
  rewrite_env (map (subst_tb X (typ_mu B)) nil ++ E).
  apply sub_generalize_intensive with (m:=Pos)...
  -
    specialize_x_and_L X L.
    apply sub_nominal_inversion in H1...
  -
    solve_notin.
  -
    simpl.
    rewrite <- subst_tt_intro...
    rewrite <- subst_tt_intro...
    apply H1...
  -
    get_well_form.
    apply Reflexivity...
  -
    inv_rt.
Qed.
