Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Reflexivity.

Definition transitivity_on Q := forall E S T,
    sub E S Q -> sub E Q T -> sub E S T.


Lemma sub_transitivity : forall Q,
  transitivity_on Q.
Proof with auto.
  intros.
  unfold transitivity_on.
  intros.
  assert (WF E Q).
  get_well_form...
  generalize dependent S.
  generalize dependent T.
  induction H1;intros...
  -
    dependent destruction H0...    
  -
    dependent destruction H0...
    constructor...
    get_well_form...
  -
    dependent induction H0...
    constructor...
    get_well_form...
    dependent induction H2...
    apply sa_trans_tvar with (U:=U0)...
    apply sa_trans_tvar with (U:=U1)...
    apply IHsub0 with (X0:=X)...
  -
    dependent induction H0...
    constructor...
    get_well_form...
    dependent induction H...
    apply sa_trans_tvar with (U:=U)...
    apply IHsub with (A0:=A) (B0:=B)...
  -
    dependent induction H3...
    apply sa_trans_tvar with (U:=U)...
    apply IHsub with (T3:=T1) (T4:=T2)...
    dependent induction H2...
    constructor...
    apply WF_all with (L:=L0);intros...
    apply H4 in H7.
    get_well_form...
    apply sa_all with (L:=L \u L0 \u L1)...
  -
    dependent induction H3...
    constructor...
    get_well_form...
    clear H6.
    dependent induction H7...
    apply sa_trans_tvar with (U:=U)...
    apply IHsub with (A0:=A)...
    clear H9.
    apply sa_rec with (L:=L \u L0 \u L1);intros...
  -
    dependent induction H0...
    constructor...
    get_well_form...
    clear IHsub.
    dependent induction H...
    apply sa_trans_tvar with (U:=U)...
    apply IHsub with (X0:=X) (A0:=A)...
Qed.



Lemma wf_env_narrowing: forall F Z Q E P,
    wf_env (F ++ Z ~ bind_sub Q ++ E) ->
    WF E P ->
    wf_env  (F ++ Z ~ bind_sub P ++ E).
Proof with auto.
  induction F;intros...
  -
    simpl...
    dependent destruction H...
    constructor...
  -
    dependent destruction H...
    +
      rewrite_env ((X, bind_sub T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
    +
      rewrite_env ((x, bind_typ T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
Qed.    

Lemma sub_narrowing_aux : forall Q F E Z P S T,
  transitivity_on Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  generalize dependent P.
  dependent induction H0;intros...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    destruct (X==Z);subst...
    +
      apply sa_trans_tvar with (U:=P)...
      apply H...
      * Case "P < Q".
        rewrite_env (nil ++ (F ++ Z ~ bind_sub P) ++ E).
        apply Sub_weakening...
        get_well_form...
        rewrite_env (F ++ Z ~ bind_sub P ++ E).
        apply wf_env_narrowing with (Q:=Q)...
      * Case "Q < T".
        analyze_binds_uniq H1...
        apply uniq_from_wf_env...
        get_well_form...
        dependent destruction BindsTacVal.
        apply IHsub with (Q0:=Q)...
    +
      apply sa_trans_tvar with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    constructor...
    apply IHsub1 with (Q0:=Q)...
    apply IHsub2 with (Q0:=Q)...
  -
    apply sa_all with (L:=L);intros...
    +
      apply WF_narrowing with (V:=Q)...
    +
      rewrite_env ((X ~ bind_sub S ++ F) ++ Z ~ bind_sub P ++ E).
      apply H1 with (Q0:=Q)...
  -
    apply sa_rec with (L:=L \u fv_tt A1 \u fv_tt A2);intros...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      rewrite_env (X ~ bind_sub typ_top ++ F ++ Z ~ bind_sub Q ++ E)...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      rewrite_env (X ~ bind_sub typ_top ++ F ++ Z ~ bind_sub Q ++ E)...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply H2 with (Q0:=Q)...
  -
    constructor.
    apply IHsub with (Q0:=Q)...
Qed.

Lemma sub_narrowing : forall Q E F Z P S T,
  sub E P Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  apply sub_narrowing_aux with (Q:=Q)...
  apply sub_transitivity.
Qed.
