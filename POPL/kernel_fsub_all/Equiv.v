Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Transitivity.

Lemma wf_env_map_free: forall E1 E2 X C B,
    wf_env (E1 ++ X~B++ E2) ->
    WF (X ~ B ++ E2) C ->
    wf_env ((map (subst_tb X C) E1)++ X~B++E2).
Proof with auto.
  induction E1;intros...
  destruct a.
  rewrite_env ((a, b) :: E1 ++ X~B++ E2) in H.
  simpl...
  rewrite_env  ((a, subst_tb X C b) :: (map (subst_tb X C) E1 ++ (X,B)::E2)).
  destruct b;simpl...
  -
    dependent destruction H.
    constructor...
    apply IHE1...
    rewrite_env (map (subst_tb X C) E1 ++ [(X, B)] ++ E2).
    apply subst_tb_wf2 with (Q:=B)...
  -
    dependent destruction H.
    constructor...
    apply IHE1...
    rewrite_env (map (subst_tb X C) E1 ++ [(X, B)] ++ E2).
    apply subst_tb_wf2 with (Q:=B)...
  -
    dependent destruction H.
    constructor...
    apply IHE1...
    rewrite_env (map (subst_tb X C) E1 ++ [(X, B)] ++ E2).
    apply subst_tb_wf2 with (Q:=B)...
Qed.

Lemma wf_env_map_free2: forall E1 E2 X C B,
    wf_env (E1 ++ X~B++ E2) ->
    WF  E2 C ->
    wf_env ((map (subst_tb X C) E1)++ E2).
Proof with auto.
  induction E1;intros;simpl...
  dependent destruction H...
  destruct a.
  rewrite_env ((a, b) :: E1 ++ X~B++ E2) in H.
  simpl...
  rewrite_env  ((a, subst_tb X C b) :: (map (subst_tb X C) E1 ++ E2)).
  destruct b;simpl...
  -
    dependent destruction H.
    constructor...
    apply IHE1 with (B:=B)...
    apply subst_tb_wf with (Q:=B)...
  -
    dependent destruction H.
    constructor...
    apply IHE1 with (B:=B)...
    apply subst_tb_wf with (Q:=B)...
  -
    dependent destruction H.
    constructor...
    apply IHE1 with (B:=B)...
    apply subst_tb_wf with (Q:=B)...
Qed.

 
Lemma binds_map_free_env: forall E1 E2 X Y U T S,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub T) :: E2) ->
    binds X (bind_sub U) (E1 ++ (Y, bind_sub T) :: E2) ->
    binds X (bind_sub (subst_tt Y S U)) (map (subst_tb Y S) E1 ++ (Y, bind_sub T) :: E2).
Proof with auto.
  intros.
  unfold binds in *.
  apply binds_map_free with (Y:=Y) (P:=S) in H1...
  apply notin_from_wf_env in H0.
  rewrite_env (map (subst_tb Y S) E1 ++ map (subst_tb Y S) [(Y, bind_sub T)] ++ map (subst_tb Y S) E2) in H1.
  simpl in H1...
  assert (map (subst_tb Y S) E2 = E2).
  rewrite maps_subst_tb_free ...
  rewrite H2 in H1...
  assert (subst_tt Y S T = T).
  rewrite <- subst_tt_fresh...
  rewrite H3 in H1...
Qed.


Lemma binds_map_free_env_lb: forall E1 E2 X Y U T S,
    Y \notin {{X}}  ->
    wf_env (E1 ++ (Y, bind_sub T) :: E2) ->
    binds X (bind_sub_lb U) (E1 ++ (Y, bind_sub T) :: E2) ->
    binds X (bind_sub_lb (subst_tt Y S U)) (map (subst_tb Y S) E1 ++ (Y, bind_sub T) :: E2).
Proof with auto.
  intros.
  unfold binds in *.
  apply binds_map_free_lb with (Y:=Y) (P:=S) in H1...
  apply notin_from_wf_env in H0.
  rewrite_env (map (subst_tb Y S) E1 ++ map (subst_tb Y S) [(Y, bind_sub T)] ++ map (subst_tb Y S) E2) in H1.
  simpl in H1...
  assert (map (subst_tb Y S) E2 = E2).
  rewrite maps_subst_tb_free ...
  rewrite H2 in H1...
  assert (subst_tt Y S T = T).
  rewrite <- subst_tt_fresh...
  rewrite H3 in H1...
Qed.


Lemma equiv_subst_refl: forall E A,
    WF E A -> forall C D X,
    equiv E C D ->
    equiv E (subst_tt X C A) (subst_tt X D A).
Proof with auto.
  intros E A H.
  unfold equiv.
  assert (type A).
  get_type...
  apply type_to_rec in H0.
  generalize dependent E.
  dependent induction H0;intros;simpl;try solve [destruct_hypos;get_well_form;split;auto]...
  -
    destruct_hypos.
    split.
    +
      destruct (X==X0);subst...
      get_well_form.
      constructor...
    +
      destruct (X==X0);subst...
      get_well_form.
      constructor...
  -
    dependent destruction H.
    destruct_hypos.
    split.
    +
      constructor...
      apply IHtype4rec1...
      apply IHtype4rec2...
    +
      constructor...
      apply IHtype4rec1...
      apply IHtype4rec2...
  -
    dependent destruction H3.
    destruct_hypos.
    split.
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      apply sa_rec with (L:=L \u L0 \u {{X}} \u dom E);intros...
      *
        rewrite subst_tt_open_tt_var...
        apply subst_tt_wf...
        get_well_form.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply WF_weakening...
      *
        rewrite subst_tt_open_tt_var...
        apply subst_tt_wf...
        get_well_form.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply WF_weakening...
      *
        rewrite <- subst_tt_open_tt_twice...
        rewrite <- subst_tt_open_tt_twice...
        apply H0...
        split.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      apply sa_rec with (L:=L \u L0 \u {{X}} \u dom E);intros...
      *
        rewrite subst_tt_open_tt_var...
        apply subst_tt_wf...
        get_well_form.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply WF_weakening...
      *
        rewrite subst_tt_open_tt_var...
        apply subst_tt_wf...
        get_well_form.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply WF_weakening...
      *
        rewrite <- subst_tt_open_tt_twice...
        rewrite <- subst_tt_open_tt_twice...
        apply H0...
        split.
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub typ_top ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
  -
    dependent destruction H2.
    destruct_hypos.
    split.
    +
      apply sa_all with (L:=L \u L0 \u {{X}} \u dom E);intros...
      apply IHtype4rec...
      apply IHtype4rec...
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H1...
      *
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X D T1) ++ E).
        apply WF_narrowing with (V:=T1)...
        apply H3...
      *
        split.
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X D T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X D T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
      *
        get_type...
      *
        get_type...
    +
      apply sa_all with (L:=L \u L0 \u {{X}} \u dom E);intros...
      apply IHtype4rec...
      apply IHtype4rec...
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H1...
      *
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X C T1) ++ E).
        apply WF_narrowing with (V:=T1)...
        apply H3...
      *
        split.
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X C T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X C T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
      *
        get_type...
      *
        get_type...
  -
    dependent destruction H2.
    destruct_hypos.
    split.
    +
      apply sa_all_lb with (L:=L \u L0 \u {{X}} \u dom E);intros...
      apply IHtype4rec...
      apply IHtype4rec...
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H1...
      *
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X D T1) ++ E).
        apply WF_narrowing_lb with (V:=T1)...
        apply H3...
      *
        split.
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X D T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X D T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
      *
        get_type...
      *
        get_type...
    +
      apply sa_all_lb with (L:=L \u L0 \u {{X}} \u dom E);intros...
      apply IHtype4rec...
      apply IHtype4rec...
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H1...
      *
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X C T1) ++ E).
        apply WF_narrowing_lb with (V:=T1)...
        apply H3...
      *
        split.
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X C T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
        rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X C T1) ++ E).
        apply Sub_weakening...
        constructor...
        get_well_form...
        apply subst_tt_wf...
        get_well_form...
      *
        get_type...
      *
        get_type...
  -
    dependent destruction H.
    destruct_hypos.
    split.
    +
      constructor...
      apply IHtype4rec...
    +
      constructor...
      apply IHtype4rec...
Qed.      


Lemma WF_narrowing_env_subst: forall E1 E2 X T S,
    WF (E1 ++ X ~ bind_sub typ_top ++ E2) T ->
    wf_env (E1 ++ X ~ bind_sub typ_top ++ E2) ->
    WF (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2) T.
Proof with auto.
  intros.
  assert (type T).
  get_type...
  apply type_to_rec in H1.
  generalize dependent E1.
  generalize dependent E2.
  generalize dependent X.
  induction H1;intros;try solve [dependent destruction H;auto]...
  -
    dependent destruction H.
    * analyze_binds_uniq H.
      apply uniq_from_wf_env...
      +
        apply WF_var with (U:=subst_tt X0 S U).
        apply binds_map_free_env...
      +
        apply WF_var with (U:=typ_top)...
      +
        apply WF_var with (U:=U)...
    * analyze_binds_uniq H.
      apply uniq_from_wf_env...
      +
        apply WF_var_lb with (U:=subst_tt X0 S U).
        apply binds_map_free_env_lb...
      +
        apply WF_var_lb with (U:=U)...

  -
    dependent destruction H3...
    apply WF_rec with (L:=L \u L0 \u dom E1 \u dom E2 \u {{X}});intros...
    +
      rewrite_env (map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ X ~ bind_sub typ_top ++ E2).
      apply H2...
      apply H3...
      constructor...
    +
      rewrite_env (map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ X ~ bind_sub typ_top ++ E2).
      apply H0...
      apply H4...
      constructor...
  -
    dependent destruction H2...
    apply WF_all with (L:=L \u L0 \u dom E1 \u dom E2 \u {{X}});intros...
    rewrite_env (nil ++ X0 ~ bind_sub T1 ++ map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
    apply WF_narrowing with (V:=subst_tt X S T1).
    rewrite_env (map (subst_tb X S) (X0 ~ bind_sub T1 ++ E1) ++ X ~ bind_sub typ_top ++ E2).
    apply H0...
    apply H3...
    constructor...
  -
    dependent destruction H2...
    apply WF_all_lb with (L:=L \u L0 \u dom E1 \u dom E2 \u {{X}});intros...
    rewrite_env (nil ++ X0 ~ bind_sub_lb T1 ++ map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
    apply WF_narrowing_lb with (V:=subst_tt X S T1).
    rewrite_env (map (subst_tb X S) (X0 ~ bind_sub_lb T1 ++ E1) ++ X ~ bind_sub typ_top ++ E2).
    apply H0...
    apply H3...
    constructor...
Qed.    
    
    
Lemma equiv_sub_subst_refl: forall A X E1 E2 C D S,
    WF (E1 ++ X ~ bind_sub typ_top ++ E2) A ->
    wf_env (E1 ++ X ~ bind_sub typ_top ++ E2) ->
    equiv (X ~ bind_sub typ_top ++ E2) C D ->
    equiv (X ~ bind_sub typ_top ++ E2) C S ->
    equiv (X ~ bind_sub typ_top ++ E2) S D ->
    sub (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X C A) (subst_tt X D A).
Proof with auto.
  intros.
  unfold equiv in *.
  destruct_hypos.
  assert (type A) as Hq.
  get_type...
  apply type_to_rec in Hq.
  generalize dependent E1.
  generalize dependent E2.
  generalize dependent X.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction Hq;intros;simpl...
  -
    constructor...
    apply wf_env_map_free...
    get_well_form...
  -
    constructor...
    apply wf_env_map_free...
    get_well_form...
  -
    constructor...
    apply wf_env_map_free...
    get_well_form...
  -
    destruct (X==X0);subst...
    +
      rewrite_env (nil ++ map (subst_tb X0 S) E1 ++ (X0, bind_sub typ_top) :: E2).
      apply Sub_weakening...
      apply wf_env_map_free...
      get_well_form...
    +
      constructor...
      apply wf_env_map_free...
      get_well_form...
      dependent destruction H.
      * analyze_binds H...
        apply WF_var with (U:=subst_tt X0 S U)...
        unfold binds in *.
        apply In_lemmaL.
        apply binds_map_free...
        apply WF_var with (U:= U)...
      * analyze_binds H...
        apply WF_var_lb with (U:=subst_tt X0 S U)...
        unfold binds in *.
        apply In_lemmaL.
        apply binds_map_free_lb...
        apply WF_var_lb with (U:= U)...
  -
    dependent destruction H.
    constructor...
    apply IHHq1...
    apply IHHq2...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H9.
    apply sa_rec with (L:=L \u {{X}} \u dom E1 \u dom E2 \u L0);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply subst_tt_wf...
      rewrite_env (nil ++ map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ (X~ bind_sub typ_top) ++ E2).
      apply WF_weakening...
      get_well_form...
      apply WF_narrowing_env_subst...
      apply H9...
      constructor...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply subst_tt_wf...
      rewrite_env (nil ++ map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ (X~ bind_sub typ_top) ++ E2).
      apply WF_weakening...
      get_well_form...
      apply WF_narrowing_env_subst...
      apply H9...
      constructor...
    +
      rewrite <- subst_tt_open_tt_twice...
      rewrite <- subst_tt_open_tt_twice...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++ (X, bind_sub typ_top) :: E2).
      apply H0...
      apply H10...
      constructor...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H7.
    apply sa_all with (L:=L \u L0 \u {{X}} \u dom E1 \u dom E2);intros...
    +
      apply IHHq...
    +
      apply IHHq...
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env ( nil ++ X0 ~ bind_sub (subst_tt X D T1) ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
      apply sub_narrowing with (Q:=subst_tt X S T1).
      *
        assert (Hv:=H7).
        apply WF_narrowing_env_subst with (S:=S) in H7...
        apply equiv_subst_refl with (C:=D) (D:=S) (X:=X) in H7...
        apply IHHq...
        get_well_form;apply Reflexivity...
        get_well_form;apply Reflexivity...
        unfold equiv;rewrite_env (nil ++ map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2);
        split;apply Sub_weakening...
        apply wf_env_map_free...
        get_well_form...
        apply wf_env_map_free...
        get_well_form...
      *
        rewrite_env (map (subst_tb X S) (X0 ~ bind_sub T1 ++ E1) ++ (X, bind_sub typ_top) :: E2).
        apply H0...
        apply H8...
        constructor...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H7.
    apply sa_all_lb with (L:=L \u L0 \u {{X}} \u dom E1 \u dom E2);intros...
    +
      apply IHHq...
    +
      apply IHHq...
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env ( nil ++ X0 ~ bind_sub_lb (subst_tt X D T1) ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
      apply sub_narrowing_lb with (Q:=subst_tt X S T1).
      *
        assert (Hv:=H7).
        apply WF_narrowing_env_subst with (S:=S) in H7...
        apply equiv_subst_refl with (C:=D) (D:=S) (X:=X) in H7...
        apply IHHq...
        get_well_form;apply Reflexivity...
        get_well_form;apply Reflexivity...
        unfold equiv;rewrite_env (nil ++ map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2);
        split;apply Sub_weakening...
        apply wf_env_map_free...
        get_well_form...
        apply wf_env_map_free...
        get_well_form...
      *
        rewrite_env (map (subst_tb X S) (X0 ~ bind_sub_lb T1 ++ E1) ++ (X, bind_sub typ_top) :: E2).
        apply H0...
        apply H8...
        constructor...
  -
    dependent destruction H.
    constructor...
    apply IHHq...
Qed.

Lemma equiv_sub_subst_refl_no_var: forall A X E1 E2 C D S,
    WF (E1 ++ X ~ bind_sub typ_top ++ E2) A ->
    wf_env (E1 ++ X ~ bind_sub typ_top ++ E2) ->
    equiv E2 C D ->
    equiv E2 C S ->
    equiv E2 S D ->
    sub (map (subst_tb X S) E1 ++  E2) (subst_tt X C A) (subst_tt X D A).
Proof with auto.
  intros.
  unfold equiv in *.
  destruct_hypos.
  assert (type A) as Hq.
  get_type...
  apply type_to_rec in Hq.
  generalize dependent E1.
  generalize dependent E2.
  generalize dependent X.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction Hq;intros;simpl...
  -
    constructor...
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
    get_well_form...
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
  -
    destruct (X==X0);subst...
    +
      rewrite_env (nil ++ map (subst_tb X0 S) E1 ++ E2).
      apply Sub_weakening...
      apply wf_env_map_free2 with (B:=bind_sub typ_top)...
      get_well_form...
    +
      constructor...
      apply wf_env_map_free2 with (B:=bind_sub typ_top)...
      get_well_form...
      dependent destruction H.
      * analyze_binds H...
        apply WF_var with (U:=subst_tt X0 S U)...
        unfold binds in *.
        apply In_lemmaL.
        apply binds_map_free...
        apply WF_var with (U:= U)...
      * analyze_binds H...
        apply WF_var_lb with (U:=subst_tt X0 S U)...
        unfold binds in *.
        apply In_lemmaL.
        apply binds_map_free_lb...
        apply WF_var_lb with (U:= U)...
  -
    dependent destruction H.
    constructor...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H9.
    apply sa_rec with (L:=L \u {{X}} \u dom E1 \u dom E2 \u L0);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++  E2).
      apply subst_tb_wf3...
      apply WF_narrowing with (V:=typ_top)...
      apply H9...
      get_well_form...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++  E2).
      apply subst_tb_wf3...
      apply WF_narrowing with (V:=typ_top)...
      apply H9...
      get_well_form...
    +
      rewrite <- subst_tt_open_tt_twice...
      rewrite <- subst_tt_open_tt_twice...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top ++ E1) ++ E2).
      apply H0...
      apply H10...
      constructor...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H7.
    apply sa_all with (L:=L \u L0 \u {{X}} \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env ( nil ++ X0 ~ bind_sub (subst_tt X D T1) ++ map (subst_tb X S) E1 ++ E2).
      apply sub_narrowing with (Q:=subst_tt X S T1).
      *
        assert (Hv:=H7).
        apply WF_narrowing_env_subst with (S:=S) in H7...
        apply equiv_subst_refl with (C:=D) (D:=S) (X:=X) in H7...
        apply IHHq...
        get_well_form;apply Reflexivity...
        get_well_form;apply Reflexivity...
        unfold equiv;rewrite_env (nil ++ (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top) ++ E2);
          split;apply Sub_weakening...
        rewrite_env (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
        apply wf_env_map_free...
        rewrite_env (nil ++ X ~ bind_sub typ_top ++ E2).
        apply WF_weakening...
        get_well_form...
        rewrite_env (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
        apply wf_env_map_free...
        rewrite_env (nil ++ X ~ bind_sub typ_top ++ E2).
        apply WF_weakening...
        get_well_form...
      *
        rewrite_env (map (subst_tb X S) (X0 ~ bind_sub T1 ++ E1) ++  E2).
        apply H0...
        apply H8...
        constructor... 
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    dependent destruction H7.
    apply sa_all_lb with (L:=L \u L0 \u {{X}} \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env ( nil ++ X0 ~ bind_sub_lb (subst_tt X D T1) ++ map (subst_tb X S) E1 ++ E2).
      apply sub_narrowing_lb with (Q:=subst_tt X S T1).
      *
        assert (Hv:=H7).
        apply WF_narrowing_env_subst with (S:=S) in H7...
        apply equiv_subst_refl with (C:=D) (D:=S) (X:=X) in H7...
        apply IHHq...
        get_well_form;apply Reflexivity...
        get_well_form;apply Reflexivity...
        unfold equiv;rewrite_env (nil ++ (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top) ++ E2);
          split;apply Sub_weakening...
        rewrite_env (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
        apply wf_env_map_free...
        rewrite_env (nil ++ X ~ bind_sub typ_top ++ E2).
        apply WF_weakening...
        get_well_form...
        rewrite_env (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2).
        apply wf_env_map_free...
        rewrite_env (nil ++ X ~ bind_sub typ_top ++ E2).
        apply WF_weakening...
        get_well_form...
      *
        rewrite_env (map (subst_tb X S) (X0 ~ bind_sub_lb T1 ++ E1) ++  E2).
        apply H0...
        apply H8...
        constructor...
  -
    dependent destruction H.
    constructor...
Qed.


Lemma wf_env_binds_not_fv_tt: forall F Z E Q,
    wf_env (F ++ Z ~ bind_sub Q ++ E) ->
    Z \notin fv_tt Q.
Proof with auto.
  intros.
  apply wf_env_cons in H.
  dependent destruction H...
  apply WF_imply_dom in H0...
Qed. 


Lemma wf_env_subst_tb : forall F Q Z P E,
  wf_env (F ++ Z ~ bind_sub Q ++ E) ->
  WF E P ->
  wf_env (map (subst_tb Z P) F ++ E).
Proof with eauto.
  induction F; intros ;simpl in *...
  -
    dependent destruction H...
  -
    destruct a.
    dependent destruction H;simpl in *.
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub Q)...
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub Q)...
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub Q)...
Qed.      


Lemma wf_env_subst_tb_lb : forall F Q Z P E,
  wf_env (F ++ Z ~ bind_sub_lb Q ++ E) ->
  WF E P ->
  wf_env (map (subst_tb Z P) F ++ E).
Proof with eauto.
  induction F; intros ;simpl in *...
  -
    dependent destruction H...
  -
    destruct a.
    dependent destruction H;simpl in *.
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub_lb Q)...
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub_lb Q)...
    +
      constructor...
      apply subst_tb_wf with (Q:=bind_sub_lb Q)...
Qed.
      

Lemma sub_through_subst_tt: forall Z Q T S F E P,
    sub (F ++ Z ~ bind_sub Q ++ E) T S ->
    sub E P Q ->
    sub (map (subst_tb Z P) F ++ E) (subst_tt Z P T) (subst_tt Z P S).
Proof with auto.
  intros.
  assert (WF E P) as Hq.
    get_well_form...
  dependent induction H;simpl...
  -
    constructor...
    apply wf_env_subst_tb with (Q:=Q)...
  -
    destruct (X==Z);subst...
    + apply Reflexivity...
      add_nil.
      apply WF_weakening...
      apply wf_env_subst_tb with (Q:=Q)...
    + dependent destruction H0.
      { constructor...
        apply wf_env_subst_tb with (Q:=Q)...
        apply WF_var with (U:=subst_tt Z P U)...
        apply binds_map_free_sub with (Q:=Q)... }
      { constructor...
        apply wf_env_subst_tb with (Q:=Q)...
        apply WF_var_lb with (U:=subst_tt Z P U)...
        apply binds_map_free_sub2 with (Q:=Q)... }
  -
    constructor...
    apply wf_env_subst_tb with (Q:=Q)...
    apply subst_tb_wf with (Q:=bind_sub Q)...
  -
    constructor...
    apply wf_env_subst_tb with (Q:=Q)...
    apply subst_tb_wf with (Q:=bind_sub Q)...
  -
    destruct (X==Z);subst...
    +
      apply sub_transitivity with (Q:=Q).
      *
        add_nil.
        apply Sub_weakening...
        apply wf_env_subst_tb with (Q:=Q)...
        get_well_form...
      *
        assert (Q = subst_tt Z P Q).
        rewrite <- subst_tt_fresh ...
        get_well_form.
        apply wf_env_binds_not_fv_tt in H0...
        rewrite H2.
        analyze_binds_uniq H...
        apply uniq_from_wf_env...
        get_well_form...
        inversion BindsTacVal;subst.
        apply IHsub with (Q0:=Q)...
    +
      apply sa_trans_tvar with (U:=subst_tt Z P U)...
      apply binds_map_free_sub with (Q:=Q)...
      get_well_form...
      apply IHsub with (Q0:=Q)...

  -
    destruct (X==Z);subst...
    + apply binds_mid_eq in H...
      inversion H. apply uniq_from_wf_env.
      get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=subst_tt Z P U)...
      apply binds_map_free_sub2 with (Q:=Q)...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    constructor...
    apply IHsub1 with (Q0:=Q)...
    apply IHsub2 with (Q0:=Q)...
  -
    assert (type P). get_type...
    apply sa_all with (L:=L \u {{Z}});intros...
    + apply IHsub1 with (Q0:=Q)...
    + apply IHsub2 with (Q0:=Q)...
    (* + apply subst_tb_wf with (Q:=bind_sub Q)... *)
    + rewrite_env ( map (subst_tb Z P) (X~bind_sub S2 ++ F) ++ E).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H2 with (Q0:=Q)...
  -
    assert (type P). get_type...
    apply sa_all_lb with (L:=L \u {{Z}});intros...
    + apply IHsub1 with (Q0:=Q)...
    + apply IHsub2 with (Q0:=Q)...
    (* + apply subst_tb_wf with (Q:=bind_sub Q)... *)
    + rewrite_env ( map (subst_tb Z P) (X~bind_sub_lb S2 ++ F) ++ E).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      apply H2 with (Q0:=Q)...
  -
    assert (type P). get_type...
    apply sa_rec with (L:=L \u {{Z}});intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb Z P) (X~bind_sub typ_top ++ F) ++ E).
      apply subst_tb_wf with (Q:=bind_sub Q)...
      apply H...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb Z P) (X~bind_sub typ_top ++ F) ++ E).
      apply subst_tb_wf with (Q:=bind_sub Q)...
      apply H0...
    +
      rewrite <- subst_tt_open_tt_twice...
      rewrite <- subst_tt_open_tt_twice...
      rewrite_env (map (subst_tb Z P) (X~bind_sub typ_top ++ F) ++ E).
      apply H2 with (Q0:=Q)...
  -
    constructor...
    apply IHsub with (Q0:=Q)...
  (* -
    apply sa_rcd...
    +
      apply wf_env_subst_tb with (Q:=Q)...
    +
      apply subst_tt_rt_type with (E:=F ++ Z ~ bind_sub Q ++ E)...
      add_nil. apply WF_weakening... apply WF_weakening...
    +
      apply subst_tt_rt_type with (E:=F ++ Z ~ bind_sub Q ++ E)...
      add_nil. apply WF_weakening... apply WF_weakening...
    +
      apply label_equiv_reserve with (E:=F ++ Z ~ bind_sub Q ++ E)...
      reflexivity.
    +
      apply subst_tb_wf with (Q:=bind_sub Q)...
    +
      apply subst_tb_wf with (Q:=bind_sub Q)...
    +
      intros. apply Tlookup_subst with (E:=(F ++ Z ~ bind_sub Q ++ E) )in H8 ...
      apply Tlookup_subst with (E:=(F ++ Z ~ bind_sub Q ++ E) )in H9...
      destruct_hypos. subst.
      apply H6 with (i:=i) (Q0:=Q)... *)
Qed.



Lemma equiv_sub_subst_not_var: forall A B X E1 E2 C D S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    equiv E2 C D ->
    equiv E2 C S ->
    equiv E2 S D ->
    sub (map (subst_tb X S) E1 ++ E2) (subst_tt X C A) (subst_tt X D B).
Proof with auto.
  intros.
  unfold equiv in *.
  destruct_hypos.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction H;intros;simpl...
  -
    constructor...
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
    get_well_form...
  -
    destruct (X0==X);subst...
    +
      rewrite_env (nil ++ map (subst_tb X S) E1 ++ E2).
      apply Sub_weakening...
      apply wf_env_map_free2 with (B:=bind_sub typ_top)...
      get_well_form...
    +
      constructor...
      *
        apply wf_env_map_free2 with (B:=bind_sub typ_top)...
        get_well_form...
      *
        dependent destruction H0.
        { analyze_binds H0...
          apply WF_var with (U:=subst_tt X S U)...
          unfold binds in *.
          apply In_lemmaL.
          apply binds_map_free...
          apply WF_var with (U:= U)... }
        { analyze_binds H0...
          apply WF_var_lb with (U:=subst_tt X S U)...
          unfold binds in *.
          apply In_lemmaL.
          apply binds_map_free_lb...
          apply WF_var_lb with (U:= U)... }
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
    apply subst_tb_wf3...
    apply WF_narrowing with (V:=typ_top)...
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free2 with (B:=bind_sub typ_top)...
    apply subst_tb_wf3...
    apply WF_narrowing with (V:=typ_top)...
  -
    destruct (X0==X);subst...
    +
      analyze_binds_uniq  H.
      get_well_form.
      apply uniq_from_wf_env... 
      dependent destruction BindsTacVal.
      dependent destruction H0.
      * simpl...
        constructor...
        apply wf_env_map_free2 with (B:=bind_sub typ_top)...
        get_well_form...
        get_well_form.
        rewrite_env (nil ++ map (subst_tb X S) E1 ++  E2).
        apply WF_weakening...
      * simpl... destruct (X0 ==X)...
        { add_nil. apply Sub_weakening...
          apply wf_env_map_free2 with (B:=bind_sub typ_top)...
          get_well_form... get_well_form... }
        { apply sa_trans_tvar_lb with (U:=subst_tt X S U)...
          apply binds_map_free_sub2 with (S:=S) in H...
          get_well_form...
          eapply sub_transitivity with (Q:=typ_top).
            {
              constructor...
              apply wf_env_map_free2 with (B:=bind_sub typ_top)...
              get_well_form...
              get_well_form...
              rewrite_env (nil ++ map (subst_tb X S) E1 ++  E2).
              apply WF_weakening... get_well_form...
            }
            { replace typ_top with (subst_tt X S typ_top)... 
              apply sub_through_subst_tt with (Q:=typ_top)...
              constructor;get_well_form... }
        }
    +
      apply sa_trans_tvar with (U:=subst_tt X S U)...
      *
        apply binds_map_free_sub with (Q:=typ_top)...
        get_well_form...
      *
        apply IHsub...
        get_well_form.
        apply Reflexivity...
        get_well_form.
        apply Reflexivity...
  -
    destruct (X0==X);subst...
    +
      analyze_binds_uniq  H.
      get_well_form.
      apply uniq_from_wf_env... 

    +
      apply sa_trans_tvar_lb with (U:=subst_tt X S U)...
      *
        apply binds_map_free_sub2 with (Q:=typ_top)...
        get_well_form...
      *
        apply IHsub...
        get_well_form.
        apply Reflexivity...
        get_well_form.
        apply Reflexivity...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    apply sa_all with (L:=L \u {{X}});intros...
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X D S2) ++ map (subst_tb X S) E1 ++ E2).
      apply sub_narrowing with (Q:=subst_tt X S S2).
      *
        apply equiv_sub_subst_refl_no_var;try solve [get_well_form;auto|unfold equiv;auto]...
        unfold equiv;get_well_form;split;apply Reflexivity...
      *
        rewrite_env  (map (subst_tb X S) (X0 ~ bind_sub S2 ++ E1) ++ E2).
        apply H2...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    apply sa_all_lb with (L:=L \u {{X}});intros...
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X D S2) ++ map (subst_tb X S) E1 ++ E2).
      apply sub_narrowing_lb with (Q:=subst_tt X S S2).
      *
        apply equiv_sub_subst_refl_no_var;try solve [get_well_form;auto|unfold equiv;auto]...
        unfold equiv;get_well_form;split;apply Reflexivity...
      *
        rewrite_env  (map (subst_tb X S) (X0 ~ bind_sub_lb S2 ++ E1) ++ E2).
        apply H2...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    apply sa_rec with (L:=L \u {{X}} \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ E2).
      apply subst_tb_wf3...
      rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ X ~ bind_sub S ++ E2).
      apply WF_narrowing with (V:=typ_top)...
      apply H...
      get_well_form...
    +
      rewrite subst_tt_open_tt_var...
      rewrite_env (map (subst_tb X S) (X0 ~ bind_sub typ_top ++ E1) ++ E2).
      apply subst_tb_wf3...
      rewrite_env ((X0 ~ bind_sub typ_top ++ E1) ++ X ~ bind_sub S ++ E2).
      apply WF_narrowing with (V:=typ_top)...
      apply H0...
      get_well_form...
    +
      rewrite <- subst_tt_open_tt_twice...
      rewrite <- subst_tt_open_tt_twice...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top++E1) ++  E2).
      apply H2...
Qed.
    
    
Lemma equiv_sub_subst: forall A B X E1 E2 C D S,
    sub (E1 ++ X ~ bind_sub typ_top ++ E2) A B ->
    equiv (X ~ bind_sub typ_top ++ E2) C D ->
    equiv (X ~ bind_sub typ_top ++ E2) C S ->
    equiv (X ~ bind_sub typ_top ++ E2) S D ->
    sub (map (subst_tb X S) E1 ++ X ~ bind_sub typ_top ++ E2) (subst_tt X C A) (subst_tt X D B).
Proof with auto.
  intros.
  unfold equiv in *.
  destruct_hypos.
  generalize dependent C.
  generalize dependent D.
  generalize dependent S.
  dependent induction H;intros;simpl...
  -
    constructor...
    apply wf_env_map_free...
    get_well_form...
  -
    destruct (X0==X);subst...
    +
      rewrite_env (nil ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
      apply Sub_weakening...
      apply wf_env_map_free...
      get_well_form...
    +
      constructor...
      *
        apply wf_env_map_free...
        get_well_form...
      *
        dependent destruction H0.
        { analyze_binds H0...
          + apply WF_var with (U:=subst_tt X S U)...
            unfold binds in *.
            apply In_lemmaL.
            apply binds_map_free...
          + apply WF_var with (U:= U)... }
        { analyze_binds H0...
          + apply WF_var_lb with (U:=subst_tt X S U)...
            unfold binds in *.
            apply In_lemmaL.
            apply binds_map_free_lb...
          + apply WF_var_lb with (U:= U)... }
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free...
    apply subst_tt_wf...
    rewrite_env (nil ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
    apply WF_weakening...
    apply WF_narrowing_env_subst...
  -
    get_well_form...
    constructor...    
    apply wf_env_map_free...
    apply subst_tt_wf...
    rewrite_env (nil ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
    apply WF_weakening...
    apply WF_narrowing_env_subst...
  -
    destruct (X0==X);subst...
    +
      analyze_binds_uniq  H.
      get_well_form.
      apply uniq_from_wf_env... 
      inversion BindsTacVal.
      subst. clear IHsub.
      dependent induction H0.
      * simpl...
        constructor...
        apply wf_env_map_free...
        get_well_form...
        get_well_form.
        rewrite_env (nil ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
        apply WF_weakening...
      *
        simpl... destruct (X0 == X)...
        { add_nil. apply Sub_weakening...
          apply wf_env_map_free;get_well_form... }
        { apply sa_trans_tvar_lb with (U:= subst_tt X S U)...
          * apply binds_map_free_sub2 with (S:=S) in H...
            2:{ get_well_form... }
            apply binds_app_iff in H. destruct H.
            apply binds_app_iff... apply binds_app_iff.
            right. apply binds_cons...
          * apply IHsub...
            apply Reflexivity;get_well_form...
            apply Reflexivity;get_well_form...
        }
    + apply sa_trans_tvar with (U:= subst_tt X S U)...
      * apply binds_map_free_sub with (S:=S) in H...
        2:{ get_well_form... }
        apply binds_app_iff in H. destruct H.
        apply binds_app_iff... apply binds_app_iff.
        right. apply binds_cons...
      * apply IHsub...
        apply Reflexivity;get_well_form...
        apply Reflexivity;get_well_form...
  - 
    destruct (X0==X);subst...
    +
      analyze_binds_uniq  H.
      get_well_form.
      apply uniq_from_wf_env... 
    + apply sa_trans_tvar_lb with (U:= subst_tt X S U)...
      * apply binds_map_free_sub2 with (S:=S) in H...
        2:{ get_well_form... }
        apply binds_app_iff in H. destruct H.
        apply binds_app_iff... apply binds_app_iff.
        right. apply binds_cons...
      * apply IHsub...
        apply Reflexivity;get_well_form...
        apply Reflexivity;get_well_form...
  -
    constructor...
    apply IHsub1...
    apply IHsub2...
  -
    apply sa_all with (L:=L \u {{X}});intros...
    +
      apply IHsub1...
    +
      apply IHsub2...
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ X0 ~ bind_sub (subst_tt X D S2) ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
      apply sub_narrowing with (Q:=subst_tt X S S2).
      *
        apply equiv_sub_subst_refl;try solve [get_well_form;auto|unfold equiv;auto]...
        unfold equiv;get_well_form;split;apply Reflexivity...
      *
        rewrite_env  (map (subst_tb X S) (X0 ~ bind_sub S2 ++ E1) ++ (X, bind_sub typ_top) :: E2).
        apply H2...
  -
    apply sa_all_lb with (L:=L \u {{X}});intros...
    +
      apply IHsub1...
    +
      apply IHsub2...
    +
      assert (type C) by (get_type;auto).
      assert (type D) by (get_type;auto).
      rewrite subst_tt_open_tt_var...
      rewrite subst_tt_open_tt_var...
      rewrite_env (nil ++ X0 ~ bind_sub_lb (subst_tt X D S2) ++ map (subst_tb X S) E1 ++ (X, bind_sub typ_top) :: E2).
      apply sub_narrowing_lb with (Q:=subst_tt X S S2).
      *
        apply equiv_sub_subst_refl;try solve [get_well_form;auto|unfold equiv;auto]...
        unfold equiv;get_well_form;split;apply Reflexivity...
      *
        rewrite_env  (map (subst_tb X S) (X0 ~ bind_sub_lb S2 ++ E1) ++ (X, bind_sub typ_top) :: E2).
        apply H2...
  -
    assert (type C) by (get_type;auto).
    assert (type D) by (get_type;auto).
    apply sa_rec with (L:=L \u {{X}} \u dom E1 \u dom E2);intros...
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wf...
      rewrite_env (nil ++ (X0 ~ bind_sub typ_top ++ map (subst_tb X S) E1) ++ (X, bind_sub typ_top) :: E2).
      apply WF_weakening...
      get_well_form...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top++E1) ++ (X, bind_sub typ_top) :: E2).
      apply WF_narrowing_env_subst...
      apply H...
      specialize_x_and_L X0 L.
      get_well_form...
    +
      rewrite subst_tt_open_tt_var...
      apply subst_tt_wf...
      rewrite_env (nil ++ (X0 ~ bind_sub typ_top ++ map (subst_tb X S) E1) ++ (X, bind_sub typ_top) :: E2).
      apply WF_weakening...
      get_well_form...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top++E1) ++ (X, bind_sub typ_top) :: E2).
      apply WF_narrowing_env_subst...
      apply H0...
      specialize_x_and_L X0 L.
      get_well_form...
    +
      rewrite <- subst_tt_open_tt_twice...
      rewrite <- subst_tt_open_tt_twice...
      rewrite_env (map (subst_tb X S) (X0~bind_sub typ_top++E1) ++ (X, bind_sub typ_top) :: E2).
      apply H2...
  -
    constructor...
    apply IHsub...
Qed.
    

Lemma equiv_unfolding: forall E C D X,
    equiv E (typ_mu C) (typ_mu D) ->
    X \notin fv_tt C \u fv_tt D \u dom E ->
    equiv (X~bind_sub typ_top ++ E) (typ_label X (open_tt C X)) (typ_label X (open_tt D X)).
Proof with auto.
  intros.
  unfold equiv in *.
  destruct_hypos.
  dependent destruction H.
  dependent destruction H2.
  split.
  constructor...
  pick fresh Y.
  apply sub_replacing_var with (X:=Y)...
  apply sub_nominal_inversion...
  constructor...
  specialize_x_and_L Y L.
  get_well_form...
  dependent destruction H1...
  constructor...
  pick fresh Y.
  apply sub_replacing_var with (X:=Y)...
  apply sub_nominal_inversion...
  constructor...
  specialize_x_and_L Y L.
  get_well_form...
  dependent destruction H1...
Qed.


Lemma equiv_reflexivity: forall E C,
    wf_env E ->
    WF E C ->
    equiv E C C.
Proof with auto.
  intros.
  unfold equiv;split;apply Reflexivity...
Qed.

Lemma equiv_sub_unfolding: forall C D Y E,
      sub (Y ~ bind_sub typ_top ++ E) (open_tt C Y) (open_tt D Y) ->
      sub (Y ~ bind_sub typ_top ++ E) (open_tt D Y) (open_tt C Y) ->
      Y \notin fv_tt C \u fv_tt D \u fl_tt C \u fl_tt D \u dom E \u fl_env E->
      sub E (typ_mu C) (typ_mu D).
Proof with auto.
  intros.
  apply sa_rec with (L:=dom E \u {{Y}} \u fv_tt C \u fv_tt D \u fl_tt C \u fl_tt D);intros.
  -
    get_well_form.
    apply WF_replacing_var with (X:=Y)...
  -
    get_well_form.
    apply WF_replacing_var with (X:=Y)...
  -
    apply sub_renaming_unfolding with (X:=Y)...
    +
      rewrite subst_tt_intro with (X:=Y)...
      remember (subst_tt Y (typ_label Y (open_tt C Y)) (open_tt C Y)).
      rewrite subst_tt_intro with (X:=Y)...
      rewrite_env (map (subst_tb Y (typ_label Y (open_tt C Y))) nil ++ Y ~ bind_sub typ_top ++ E).
      subst.
      apply equiv_sub_subst...
      unfold equiv;split...
      get_well_form.
      unfold equiv;split;apply Reflexivity...
      unfold equiv;split...      
    +
      constructor...
      get_well_form...
      dependent destruction H...
Qed.

