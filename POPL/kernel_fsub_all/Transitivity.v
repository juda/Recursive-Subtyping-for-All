Set Implicit Arguments.
Require Import Metalib.Metatheory.
Require Import Program.Equality.
Require Export Variance.

Inductive type4rec : typ -> Prop :=
  | type4_top :
      type4rec typ_top
  | type4_bot :
      type4rec typ_bot
  | type4_nat :
      type4rec typ_nat
  | type4_var : forall X,
      type4rec (typ_fvar X)
  | type4_arrow : forall T1 T2,
      type4rec T1 -> 
      type4rec T2 -> 
      type4rec (typ_arrow T1 T2)
  | type4_mu : forall L T,
      (forall X, X \notin L -> type4rec (open_tt T (typ_label X (open_tt T (typ_fvar X))))) ->
      (forall X, X \notin L -> type4rec (open_tt T (typ_fvar X))) ->
      type4rec (typ_mu T)
  | type4_all : forall L T1 T2,
      type4rec T1 ->
      (forall X, X `notin` L -> type4rec (open_tt T2 (typ_fvar X))) ->
      type4rec (typ_all T1 T2)
  | type4_all_lb : forall L T1 T2,
      type4rec T1 ->
      (forall X, X `notin` L -> type4rec (open_tt T2 (typ_fvar X))) ->
      type4rec (typ_all_lb T1 T2)
  | type4_label: forall l A,
      type4rec A ->
      type4rec (typ_label l A)
.

Hint Constructors type4rec : core.

Lemma type4rec_to_type : forall A,
    type4rec A -> type A.
Proof with auto.
  intros.
  induction H...
  apply type_mu with (L:=L)...
  apply type_all with (L:=L)...
  apply type_all_lb with (L:=L)...
Qed.
  
Lemma subst_tt_type4rec : forall Z P T,
  type4rec T ->
  type4rec P ->
  type4rec (subst_tt Z P T).
Proof with auto using type4rec_to_type.
  intros Z P T HT HP.
  induction HT; simpl...
  -
    destruct (X == Z)...
  -
    apply type4_mu with (L:=L \u {{Z}});intros...
    rewrite <- subst_tt_open_tt_twice...
    rewrite subst_tt_open_tt_var...
  -
    apply type4_all with (L:=L \u {{Z}});intros...
    rewrite subst_tt_open_tt_var...
  -
    apply type4_all_lb with (L:=L \u {{Z}});intros...
    rewrite subst_tt_open_tt_var...
Qed.

Lemma type_to_rec : forall A,
    type A -> type4rec A.
Proof with auto.
  intros.
  induction H...
  -
    apply type4_mu with (L:=L \u fv_tt T)...
    intros.
    rewrite subst_tt_intro with (X:=X)...
    apply subst_tt_type4rec...
  -
    apply type4_all with (L:=L \u fv_tt T1 \u fv_tt T2)...
  -
    apply type4_all_lb with (L:=L \u fv_tt T1 \u fv_tt T2)...
Qed.


Definition transitivity_on Q := forall E S T,
    sub E S Q -> sub E Q T -> sub E S T.

Lemma wf_env_narrowing: forall F Z Q E P,
    wf_env (F ++ Z ~ bind_sub Q ++ E) ->
    WF E P ->
    wf_env  (F ++ Z ~ bind_sub P ++ E).
Proof with auto.
  induction F;intros...
  -
    simpl...
    dependent destruction H...
    constructor...
  -
    dependent destruction H...
    +
      rewrite_env ((X, bind_sub T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
    +
      rewrite_env ((X, bind_sub_lb T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
    +
      rewrite_env ((x, bind_typ T) :: F ++ Z ~ bind_sub P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing with (V:=Q)...
Qed.


Lemma wf_env_narrowing_lb: forall F Z Q E P,
    wf_env (F ++ Z ~ bind_sub_lb Q ++ E) ->
    WF E P ->
    wf_env  (F ++ Z ~ bind_sub_lb P ++ E).
Proof with auto.
  induction F;intros...
  -
    simpl...
    dependent destruction H...
    constructor...
  -
    dependent destruction H...
    +
      rewrite_env ((X, bind_sub T) :: F ++ Z ~ bind_sub_lb P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing_lb with (V:=Q)...
    +
      rewrite_env ((X, bind_sub_lb T) :: F ++ Z ~ bind_sub_lb P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing_lb with (V:=Q)...
    +
      rewrite_env ((x, bind_typ T) :: F ++ Z ~ bind_sub_lb P ++ E).
      constructor...
      apply IHF with (Q:=Q)...
      apply WF_narrowing_lb with (V:=Q)...
Qed.

Lemma sub_narrowing_aux : forall Q F E Z P S T,
  transitivity_on Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub E P Q ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  generalize dependent P.
  dependent induction H0;intros...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing with (Q:=Q)...
    get_well_form...
    apply WF_narrowing with (V:=Q)...
  -
    destruct (X==Z);subst...
    +
      apply sa_trans_tvar with (U:=P)...
      apply H...
      * Case "P < Q".
        rewrite_env (nil ++ (F ++ Z ~ bind_sub P) ++ E).
        apply Sub_weakening...
        get_well_form...
        rewrite_env (F ++ Z ~ bind_sub P ++ E).
        apply wf_env_narrowing with (Q:=Q)...
      * Case "Q < T".
        analyze_binds_uniq H1...
        apply uniq_from_wf_env...
        get_well_form...
        dependent destruction BindsTacVal.
        apply IHsub with (Q0:=Q)...
    +
      apply sa_trans_tvar with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    destruct (X==Z);subst...
    + analyze_binds_uniq H1... apply uniq_from_wf_env. get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    constructor...
    apply IHsub1 with (Q0:=Q)...
    apply IHsub2 with (Q0:=Q)...
  -
    apply sa_all with (L:=L);intros...
    +
      apply IHsub1 with (Q0:=Q)...
    +
      apply IHsub2 with (Q0:=Q)...
    +
      rewrite_env ((X ~ bind_sub S2 ++ F) ++ Z ~ bind_sub P ++ E).
      apply H0 with (Q0:=Q)...
  -
    apply sa_all_lb with (L:=L);intros...
    +
      apply IHsub1 with (Q0:=Q)...
    +
      apply IHsub2 with (Q0:=Q)...
    +
      rewrite_env ((X ~ bind_sub_lb S2 ++ F) ++ Z ~ bind_sub P ++ E).
      apply H0 with (Q0:=Q)...
  -
    apply sa_rec with (L:=L \u fv_tt A1 \u fv_tt A2);intros...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      apply H3...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply WF_narrowing with (V:=Q)...
      apply H0...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub P ++ E).
      apply H2 with (Q0:=Q)...
  -
    constructor.
    apply IHsub with (Q0:=Q)...
Qed.


Lemma sub_narrowing_aux_lb : forall Q F E Z P S T,
  transitivity_on Q ->
  sub (F ++ Z ~ bind_sub_lb Q ++ E) S T ->
  sub E Q P ->
  sub (F ++ Z ~ bind_sub_lb P ++ E) S T.
Proof with auto.
  intros.
  generalize dependent P.
  dependent induction H0;intros...
  -
    constructor...
    apply wf_env_narrowing_lb with (Q:=Q)...
    get_well_form...
  -
    constructor...
    apply wf_env_narrowing_lb with (Q:=Q)...
    get_well_form...
    apply WF_narrowing_lb with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing_lb with (Q:=Q)...
    get_well_form...
    apply WF_narrowing_lb with (V:=Q)...
  -
    constructor...
    apply wf_env_narrowing_lb with (Q:=Q)...
    get_well_form...
    apply WF_narrowing_lb with (V:=Q)...
  -
    destruct (X==Z);subst...
    + analyze_binds_uniq H1... apply uniq_from_wf_env. get_well_form...
    +
      apply sa_trans_tvar with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...
  -
    destruct (X==Z);subst...
    +
      apply sa_trans_tvar_lb with (U:=P)...
      apply H...
      * Case "T < Q".
        analyze_binds_uniq H1...
        apply uniq_from_wf_env...
        get_well_form...
        dependent destruction BindsTacVal.
        apply IHsub with (Q0:=Q)...
      * Case "Q < P".
        rewrite_env (nil ++ (F ++ Z ~ bind_sub_lb P) ++ E).
        apply Sub_weakening...
        get_well_form...
        rewrite_env (F ++ Z ~ bind_sub_lb P ++ E).
        apply wf_env_narrowing_lb with (Q:=Q)...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      analyze_binds_uniq H1...
      apply uniq_from_wf_env...
      get_well_form...
      apply IHsub with (Q0:=Q)...

  -
    constructor...
    apply IHsub1 with (Q0:=Q)...
    apply IHsub2 with (Q0:=Q)...
  -
    apply sa_all with (L:=L);intros...
    +
      apply IHsub1 with (Q0:=Q)...
    +
      apply IHsub2 with (Q0:=Q)...
    +
      rewrite_env ((X ~ bind_sub S2 ++ F) ++ Z ~ bind_sub_lb P ++ E).
      apply H0 with (Q0:=Q)...
  -
    apply sa_all_lb with (L:=L);intros...
    +
      apply IHsub1 with (Q0:=Q)...
    +
      apply IHsub2 with (Q0:=Q)...
    +
      rewrite_env ((X ~ bind_sub_lb S2 ++ F) ++ Z ~ bind_sub_lb P ++ E).
      apply H0 with (Q0:=Q)...
  -
    apply sa_rec with (L:=L \u fv_tt A1 \u fv_tt A2);intros...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub_lb P ++ E).
      apply WF_narrowing_lb with (V:=Q)...
      apply H3...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub_lb P ++ E).
      apply WF_narrowing_lb with (V:=Q)...
      apply H0...
    +
      rewrite_env ((X ~ bind_sub typ_top ++ F) ++ Z ~ bind_sub_lb P ++ E).
      apply H2 with (Q0:=Q)...
  -
    constructor.
    apply IHsub with (Q0:=Q)...
Qed.

Lemma sub_top: forall E T S,  
  sub E typ_top T ->
  WF E S ->
  sub E S T.
Proof with auto.
  intros.
  dependent induction H.
  - constructor...
  - apply sa_trans_tvar_lb with (U:=U)...
Qed.


Lemma sub_bot: forall E T S,  
  sub E T typ_bot ->
  WF E S ->
  sub E T S.
Proof with auto.
  intros.
  dependent induction H.
  - constructor...
  - apply sa_trans_tvar with (U:=U)...
Qed.

(* Lemma sub_nat: forall E T U,  
  sub E typ_nat T ->
  sub E T U ->
  sub E typ_nat U.
Proof with auto.
  intros.
  dependent induction H...
  - apply sub_top...
  - apply IHsub... apply sa_trans_tvar_lb with (U:=U0)...
Qed. *)

Lemma binds_ub_lb_invalid: forall E X U U0,
  binds X (bind_sub_lb U) E ->
  binds X (bind_sub U0) E ->
  uniq E ->
  False.
Proof.
  intros.
  pose proof binds_unique _ _ _ _ _ H H0 H1.
  inversion H2.
Qed.


Lemma sub_transitivity : forall Q,
  transitivity_on Q.
Proof with auto.
  intros.
  unfold transitivity_on.
  intros.
  assert (type Q).
  get_type...
  apply type_to_rec in H1.
  generalize dependent S.
  generalize dependent T.
  generalize dependent E.
  induction H1;intros...
  -
    apply sub_top... get_well_form...
  -
    apply sub_bot... get_well_form...
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    + apply sa_trans_tvar_lb with (U:=U)...
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    +
      (* S <: X /\  X <: U <: T *)
      generalize dependent T.
      generalize dependent U.
      dependent induction H1;intros...
      *
        apply sa_trans_tvar with (U:=U)...
      *
        apply sa_bot... get_well_form...
      *
        apply sa_trans_tvar with (U:=U)...
        apply IHsub with (X0:=X) (U0 := U0)...
      *
        (* T0 <:  U0 <: X /\  X <: U <: T *)
        pose proof binds_ub_lb_invalid _ _ _ H H0.
        exfalso. apply H3. apply uniq_from_wf_env. get_well_form...
    +
      (* S <: X /\  X <: U <: X0 *)
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (X0:=X)...
  -
    dependent induction H0...
    + constructor...
      get_well_form...
    +
      (* S <: T1 -> T2 /\ T1 -> T2 <: U <: X0 *)
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (T4:=T1) (T3:=T2)...
    +
      dependent induction H...
      { apply sa_bot... get_well_form... }
      apply sa_trans_tvar with (U:=U)...
      apply IHsub with (T4:=T1) (T3:=T2)...
  -
    dependent induction H3...
    + constructor...
      get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (T0:=T)...
    +
      clear H6.
      dependent induction H7...
      { apply sa_bot... apply WF_rec with (L:=L0)...
        intros. specialize_x_and_L X L0. get_well_form... }
      apply sa_trans_tvar with (U:=U)...
      apply IHsub with (T0:=T)...
      clear H9.
      apply sa_rec with (L:=L \u L0 \u L1);intros...
      apply H0 with (X:=X)...
  -
    dependent induction H2...
    + 
      constructor...
      get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (T3:=T2)(T4:=T1)...
    +
      clear H2 IHsub1 IHsub2.
      dependent induction H4...
      { apply sa_bot... apply WF_all with (L:=L0)...
        get_well_form...
        intros. specialize_x_and_L X L0. get_well_form... }
      apply sa_trans_tvar with (U:=U)...
      apply IHsub with (T4:=T1) (T3:=T2)...
      clear H2 IHsub1 IHsub2.
      apply sa_all with (L:=L \u L0 \u L1)...
      intros.
      apply H0 with (X:=X)...
      rewrite_env (nil ++ X ~ bind_sub S2 ++ E).
      apply sub_narrowing_aux with (Q:=T1)...
      unfold transitivity_on...
      apply H4...
  -
    dependent induction H2...
    + 
      constructor...
      get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (T3:=T2)(T4:=T1)...
    +
      clear H2 IHsub1 IHsub2.
      dependent induction H4...
      { apply sa_bot... apply WF_all_lb with (L:=L0)...
        get_well_form...
        intros. specialize_x_and_L X L0. get_well_form... }
      apply sa_trans_tvar with (U:=U)...
      apply IHsub with (T4:=T1) (T3:=T2)...
      clear H2 IHsub1 IHsub2.
      apply sa_all_lb with (L:=L \u L0 \u L1)...
      intros.
      apply H0 with (X:=X)...
      rewrite_env (nil ++ X ~ bind_sub_lb S2 ++ E).
      apply sub_narrowing_aux_lb with (Q:=T1)...
      unfold transitivity_on...
      apply H4...
  -
    dependent induction H0...
    +
      constructor...
      get_well_form...
    +
      apply sa_trans_tvar_lb with (U:=U)...
      apply IHsub with (l0:=l) (A0:=A)...
    +
      clear IHsub.
      dependent induction H...
      { apply sa_bot... constructor... get_well_form... }
      apply sa_trans_tvar with (U:=U)...
      apply IHsub with (l0:=l) (A0:=A)...
Qed.

Lemma sub_narrowing : forall Q E F Z P S T,
  sub E P Q ->
  sub (F ++ Z ~ bind_sub Q ++ E) S T ->
  sub (F ++ Z ~ bind_sub P ++ E) S T.
Proof with auto.
  intros.
  apply sub_narrowing_aux with (Q:=Q)...
  apply sub_transitivity.
Qed.


Lemma sub_narrowing_lb : forall Q E F Z P S T,
  sub E Q P ->
  sub (F ++ Z ~ bind_sub_lb Q ++ E) S T ->
  sub (F ++ Z ~ bind_sub_lb P ++ E) S T.
Proof with auto.
  intros.
  apply sub_narrowing_aux_lb with (Q:=Q)...
  apply sub_transitivity.
Qed.